<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>ACC Converter — Actalithic</title>
<link rel="icon" type="image/png" href="https://i.ibb.co/DfYLtMhQ/favicon.png">
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
<link rel="stylesheet" href="css/style.css">
<script>(function(){var s=localStorage.getItem('llm-theme');document.documentElement.setAttribute('data-theme',s||'dark');})()</script>
<style>
.converter-wrap{
  width:100%;max-width:760px;margin:0 auto;
  padding:2rem 1.25rem 3rem;
  display:flex;flex-direction:column;gap:1.75rem;
}
@media(min-width:600px){.converter-wrap{padding:2.5rem 1.75rem 3.5rem}}
@media(min-width:840px){.converter-wrap{padding:3rem 2rem 4rem}}

.conv-card{
  background:var(--bg2);border:1px solid var(--border);
  border-radius:10px;padding:1.5rem 1.75rem;
  display:flex;flex-direction:column;gap:1.1rem;
}
.conv-card-title{
  font-family:'Syne',sans-serif;font-weight:700;font-size:1rem;
  color:var(--ink);display:flex;align-items:center;gap:.55rem;
}
.conv-card-title .material-icons-round{font-size:18px;color:var(--purple)}
.conv-card-sub{font-size:.72rem;color:var(--muted);line-height:1.7;margin-top:-.25rem}

/* Source tabs */
.source-tabs{
  display:flex;border:1px solid var(--border);border-radius:6px;overflow:hidden;
  background:var(--bg);
}
.source-tab{
  flex:1;padding:.6rem .75rem;font-family:'DM Mono',monospace;font-size:.72rem;
  background:transparent;border:none;color:var(--muted);cursor:pointer;
  transition:all .15s;display:flex;align-items:center;justify-content:center;gap:.4rem;
  border-right:1px solid var(--border);
}
.source-tab:last-child{border-right:none}
.source-tab.active{background:var(--ink);color:var(--accent-inv)}
.source-tab .material-icons-round{font-size:14px}

/* HF catalogue */
.hf-catalogue-label{font-size:.62rem;color:var(--muted);text-transform:uppercase;letter-spacing:.08em}
.hf-model-grid{
  display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:.6rem;
}
.hf-model-card{
  border:1.5px solid var(--border);border-radius:8px;padding:.9rem 1rem;
  cursor:pointer;transition:all .15s;background:var(--bg);
  display:flex;flex-direction:column;gap:.35rem;
  -webkit-tap-highlight-color:transparent;
}
.hf-model-card:hover{border-color:var(--purple);background:var(--purple-bg)}
.hf-model-card.selected{border-color:var(--purple);background:var(--purple-bg)}
.hf-model-card.selected .hf-card-name{color:var(--purple)}
.hf-card-name{font-size:.85rem;color:var(--ink);font-weight:500;line-height:1.3}
.hf-card-meta{font-size:.6rem;color:var(--muted);display:flex;align-items:center;gap:.4rem;flex-wrap:wrap}
.hf-card-tag{
  font-size:.52rem;padding:1px 6px;border-radius:20px;
  border:1px solid var(--border);color:var(--muted);background:var(--bg3);
  white-space:nowrap;
}
.hf-card-tag.acc{border-color:var(--purple);color:var(--purple);background:var(--purple-bg)}
.hf-card-tag.q4{border-color:var(--green-dim);color:var(--green);background:var(--green-bg)}

.hf-custom-row{display:flex;gap:.5rem;align-items:flex-end}
.hf-custom-input{
  flex:1;font-family:'DM Mono',monospace;font-size:.78rem;
  padding:.55rem .85rem;border-radius:6px;
  background:var(--bg);border:1px solid var(--border2);color:var(--ink);
  outline:none;transition:border-color .15s;
}
.hf-custom-input:focus{border-color:var(--purple);box-shadow:0 0 0 2px rgba(102,51,187,.12)}
.hf-load-btn{
  font-family:'Syne',sans-serif;font-weight:700;font-size:.75rem;
  padding:.55rem 1.1rem;border-radius:6px;border:none;cursor:pointer;
  background:var(--purple);color:#fff;display:flex;align-items:center;gap:.35rem;
  white-space:nowrap;transition:all .15s;flex-shrink:0;
}
.hf-load-btn:hover{opacity:.85;transform:translateY(-1px)}
.hf-load-btn:disabled{opacity:.4;cursor:not-allowed;transform:none}
.hf-load-btn .material-icons-round{font-size:15px}

.hf-status{
  font-size:.7rem;color:var(--muted);display:none;
  align-items:center;gap:.5rem;
  padding:.65rem .85rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;
  line-height:1.6;
}
.hf-status.visible{display:flex}
.hf-status .material-icons-round{font-size:15px;flex-shrink:0}
.hf-status.ok{color:var(--green);border-color:var(--green-dim);background:var(--green-bg)}
.hf-status.err{color:var(--red);border-color:var(--red-dim);background:var(--red-bg)}
.hf-dl-progress{width:100%;height:3px;background:var(--border);border-radius:2px;overflow:hidden;margin-top:.35rem}
.hf-dl-fill{height:100%;background:var(--purple);width:0%;transition:width .3s}

/* File drop */
.drop-zone{
  border:2px dashed var(--border2);border-radius:8px;
  padding:2.75rem 1rem;text-align:center;
  cursor:pointer;transition:all .2s;background:var(--bg);
  display:flex;flex-direction:column;align-items:center;gap:.65rem;
}
.drop-zone:hover,.drop-zone.drag-over{border-color:var(--purple);background:var(--purple-bg)}
.drop-zone .material-icons-round{font-size:2.5rem;color:var(--muted)}
.drop-zone.drag-over .material-icons-round{color:var(--purple)}
.drop-label{font-size:.82rem;color:var(--muted)}
.drop-hint{font-size:.65rem;color:var(--border2)}
.drop-file-name{
  font-size:.75rem;color:var(--green);font-weight:500;
  display:flex;align-items:center;gap:.35rem;
  padding:.4rem .75rem;background:var(--green-bg);
  border-radius:20px;border:1px solid var(--green-dim);
}

/* Presets */
.preset-grid{
  display:grid;grid-template-columns:repeat(auto-fill,minmax(170px,1fr));gap:.65rem;
}
.preset-card{
  border:1.5px solid var(--border);border-radius:8px;padding:1rem 1.1rem;
  cursor:pointer;transition:all .15s;background:var(--bg);
  display:flex;flex-direction:column;gap:.35rem;
  -webkit-tap-highlight-color:transparent;
}
.preset-card:hover{border-color:var(--purple);background:var(--purple-bg)}
.preset-card.active{border-color:var(--purple);background:var(--purple-bg)}
.preset-card.active .preset-name{color:var(--purple)}
.preset-name{font-family:'Syne',sans-serif;font-weight:700;font-size:.88rem;color:var(--ink)}
.preset-desc{font-size:.65rem;color:var(--muted);line-height:1.6}
.preset-tags{display:flex;gap:.35rem;flex-wrap:wrap;margin-top:.25rem}
.preset-tag{
  font-size:.5rem;padding:1px 6px;border-radius:20px;
  border:1px solid var(--border);color:var(--muted);background:var(--bg3);
}
.preset-tag.green{border-color:var(--green-dim);color:var(--green);background:var(--green-bg)}
.preset-tag.purple{border-color:var(--purple-dim);color:var(--purple);background:var(--purple-bg)}
.preset-tag.blue{border-color:var(--blue);color:var(--blue);background:var(--blue-bg)}
.preset-tag.amber{border-color:var(--amber-dim);color:var(--amber);background:var(--amber-bg)}

.speed-estimate{
  display:none;align-items:center;gap:.6rem;
  padding:.65rem 1rem;background:var(--green-bg);
  border:1px solid var(--green-dim);border-radius:6px;
  font-size:.7rem;color:var(--green);line-height:1.6;
}
.speed-estimate.visible{display:flex}
.speed-estimate .material-icons-round{font-size:16px;flex-shrink:0}

/* Expert */
.expert-toggle{
  font-size:.68rem;color:var(--muted);cursor:pointer;
  display:flex;align-items:center;gap:.35rem;
  transition:color .15s;user-select:none;width:fit-content;
}
.expert-toggle:hover{color:var(--ink)}
.expert-toggle .material-icons-round.chevron{font-size:14px;transition:transform .2s}
.expert-toggle.open .material-icons-round.chevron{transform:rotate(180deg)}
.expert-panel{display:none;flex-direction:column;gap:1rem;padding-top:.25rem}
.expert-panel.open{display:flex}

.options-grid{display:grid;grid-template-columns:1fr 1fr;gap:1rem}
@media(max-width:480px){.options-grid{grid-template-columns:1fr}}
.opt-field{display:flex;flex-direction:column;gap:.4rem}
.opt-label{font-size:.62rem;color:var(--muted);text-transform:uppercase;letter-spacing:.08em}
.opt-select,.opt-input{
  font-family:'DM Mono',monospace;font-size:.78rem;
  padding:.55rem .85rem;border-radius:6px;
  background:var(--bg);border:1px solid var(--border2);color:var(--ink);
  outline:none;transition:border-color .15s;
}
.opt-select:focus,.opt-input:focus{border-color:var(--purple)}

.tok-drop{
  border:1.5px dashed var(--border);border-radius:6px;
  padding:.65rem .85rem;font-size:.72rem;color:var(--muted);
  cursor:pointer;transition:all .15s;background:var(--bg);
  display:flex;align-items:center;gap:.4rem;
}
.tok-drop:hover{border-color:var(--purple);color:var(--purple);background:var(--purple-bg)}
.tok-drop.loaded{border-color:var(--green);color:var(--green);background:var(--green-bg)}

.opt-metrics{
  display:flex;gap:.45rem;flex-wrap:wrap;padding:.6rem .85rem;
  background:var(--bg3);border-radius:6px;border:1px solid var(--border);font-size:.65rem;
}
.opt-metric{
  display:flex;align-items:center;gap:.3rem;color:var(--muted);
  padding:2px 8px;border-radius:20px;border:1px solid var(--border);background:var(--bg);
  white-space:nowrap;
}
.opt-metric.ok{color:var(--green);border-color:var(--green-dim);background:var(--green-bg)}
.opt-metric.hi{color:var(--purple);border-color:var(--purple-dim);background:var(--purple-bg)}
.opt-metric .material-icons-round{font-size:11px}

/* Convert button */
.conv-btn{
  width:100%;padding:1rem;
  font-family:'Syne',sans-serif;font-weight:700;font-size:.92rem;
  letter-spacing:.04em;border-radius:8px;
  background:var(--accent);color:var(--accent-inv);border:none;
  cursor:pointer;transition:all .18s;
  display:flex;align-items:center;justify-content:center;gap:.5rem;min-height:52px;
}
.conv-btn:hover{opacity:.88;transform:translateY(-2px);box-shadow:0 6px 24px var(--shadow-lg)}
.conv-btn:active{transform:scale(.97);box-shadow:none}
.conv-btn:disabled{opacity:.4;cursor:not-allowed;transform:none;box-shadow:none}

/* Progress */
.progress-section{display:none}
.progress-section.visible{display:block}
.progress-log{
  font-size:.65rem;color:var(--muted);
  max-height:160px;overflow-y:auto;
  border:1px solid var(--border);border-radius:6px;
  padding:.6rem .85rem;background:var(--bg);
  display:flex;flex-direction:column;gap:.2rem;margin-top:.85rem;
}
.log-line{display:flex;gap:.5rem;align-items:baseline}
.log-pct{color:var(--purple);flex-shrink:0;width:3.2em;text-align:right;font-weight:500}
.log-msg{color:var(--ink2);line-height:1.5}

/* Results */
.result-section{display:none}
.result-section.visible{display:flex;flex-direction:column;gap:.75rem}
.result-stat{
  display:flex;justify-content:space-between;align-items:center;
  padding:.55rem 0;border-bottom:1px solid var(--border);font-size:.75rem;
}
.result-stat:last-of-type{border-bottom:none}
.result-stat-label{color:var(--muted)}
.result-stat-val{color:var(--ink);font-weight:500}
.result-stat-val.green{color:var(--green)}
.result-stat-val.purple{color:var(--purple)}

.action-row{display:flex;gap:.65rem;flex-wrap:wrap;margin-top:.25rem}
.action-btn{
  flex:1;min-width:150px;padding:.8rem .5rem;
  font-family:'Syne',sans-serif;font-weight:700;font-size:.78rem;
  border-radius:8px;border:1.5px solid var(--border2);
  background:var(--bg2);color:var(--ink);cursor:pointer;
  display:flex;align-items:center;justify-content:center;gap:.4rem;transition:all .15s;
}
.action-btn:hover{border-color:var(--purple);color:var(--purple);background:var(--purple-bg)}
.action-btn.primary{background:var(--accent);color:var(--accent-inv);border-color:var(--accent)}
.action-btn.primary:hover{opacity:.85;border-color:var(--accent)}
.action-btn .material-icons-round{font-size:16px}

.conv-info{
  background:var(--blue-bg);border:1px solid var(--blue);
  border-radius:8px;padding:.8rem 1rem;font-size:.7rem;
  color:var(--blue);display:flex;gap:.55rem;align-items:flex-start;line-height:1.7;
}
.conv-info .material-icons-round{font-size:15px;flex-shrink:0;margin-top:1px}

.arch-badge{
  font-size:.6rem;padding:2px 7px;border-radius:20px;
  border:1px solid var(--purple);color:var(--purple);
  background:var(--purple-bg);font-weight:500;display:inline-block;margin-left:.4rem;
}
.conv-page-title{
  font-family:'Syne',sans-serif;font-weight:800;
  font-size:clamp(1.5rem,6vw,2.2rem);letter-spacing:-.04em;
  color:var(--ink);line-height:1.1;
}
.conv-page-title span{color:var(--purple)}
.conv-page-sub{
  font-size:.78rem;color:var(--muted);line-height:1.8;margin-top:.5rem;max-width:540px;
}
</style>
</head>
<body>
<!-- ── HEADER ── -->
<header>
  <div class="header-brand">
    <img class="logo-img logo-light" src="https://i.ibb.co/mV4rQV7B/Chat-GPT-Image-18-Feb-2026-08-42-07.png" alt="LocalLLM by Actalithic">
    <img class="logo-img logo-dark"  src="https://i.ibb.co/tpSTrg7Z/whitelogo.png" alt="LocalLLM by Actalithic">
  </div>
  <div class="header-right">
    <a class="icon-btn" href="index.html" title="LocalLLM"><span class="material-icons-round">home</span></a>
    <a class="icon-btn bsky" href="https://bsky.app/profile/actalithic.bsky.social" target="_blank" rel="noopener" title="Bluesky">
      <svg viewBox="0 0 600 530" xmlns="http://www.w3.org/2000/svg"><path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z" fill="currentColor"/></svg>
    </a>
    <button class="icon-btn" onclick="toggleTheme()" title="Toggle theme">
      <span class="material-icons-round" id="themeIcon">light_mode</span>
    </button>
  </div>
</header>

<div class="converter-wrap">

  <div>
    <div class="conv-page-title">.acc <span>Converter</span></div>
    <div class="conv-page-sub">
      Admin tool — pick a model, choose an optimization, and convert. Weights download automatically. Nothing leaves your device.
    </div>
  </div>

  <!-- ══ STEP 1: Pick model ══ -->
  <div class="conv-card">
    <div class="conv-card-title">
      <span class="material-icons-round">model_training</span>
      1 — Choose model
    </div>
    <div class="conv-card-sub">Select which model to compile. Weights will download automatically from HuggingFace when you hit Convert.</div>
    <div class="hf-model-grid" id="modelPickerGrid"></div>

    <!-- Download status — hidden until Convert is pressed -->
    <div class="hf-status" id="dlStatus" style="display:none">
      <div style="flex:1">
        <div style="display:flex;align-items:center;gap:.5rem">
          <span class="material-icons-round" id="dlStatusIcon" style="font-size:15px">downloading</span>
          <span id="dlStatusText">Downloading…</span>
        </div>
        <div class="hf-dl-progress" id="dlProgress">
          <div class="hf-dl-fill" id="dlFill"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ══ STEP 2: Preset ══ -->
  <div class="conv-card">
    <div class="conv-card-title">
      <span class="material-icons-round">auto_fix_high</span>
      2 — Optimization
    </div>
    <div class="conv-card-sub">Choose how the model is quantized. Extreme Speed is recommended for all ACC models.</div>

    <div class="preset-grid" id="presetGrid"></div>

    <div class="speed-estimate" id="speedEstimate">
      <span class="material-icons-round">bolt</span>
      <div id="speedEstimateText"></div>
    </div>

    <!-- Expert options (collapsed by default) -->
    <div style="display:flex;flex-direction:column;gap:.75rem">
      <div class="expert-toggle" id="expertToggle" onclick="toggleExpert()">
        <span class="material-icons-round chevron">expand_more</span>
        <span class="material-icons-round" style="font-size:13px">tune</span>
        Advanced options
      </div>
      <div class="expert-panel" id="expertPanel">
        <div class="options-grid">
          <div class="opt-field">
            <div class="opt-label">Quantization</div>
            <select class="opt-select" id="quantMode" onchange="onExpertChange()">
              <option value="q4" selected>Q4 — 4-bit (fastest · smallest)</option>
              <option value="q8">Q8 — 8-bit (balanced quality)</option>
              <option value="f16">F16 — half precision</option>
              <option value="f32">F32 — full precision (debug)</option>
            </select>
          </div>
          <div class="opt-field">
            <div class="opt-label">Shard size</div>
            <select class="opt-select" id="shardSize" onchange="onExpertChange()">
              <option value="134217728">128 MB</option>
              <option value="268435456">256 MB</option>
              <option value="536870912" selected>512 MB (recommended)</option>
              <option value="1073741824">1 GB</option>
            </select>
          </div>
        </div>
        <div class="opt-metrics" id="optMetrics">
          <span style="color:var(--muted);font-size:.63rem;margin-right:.2rem">Config:</span>
          <span class="opt-metric" id="metricQuant"><span class="material-icons-round">compress</span>—</span>
          <span class="opt-metric" id="metricShard"><span class="material-icons-round">storage</span>—</span>
          <span class="opt-metric" id="metricSpeed"><span class="material-icons-round">speed</span>—</span>
          <span class="opt-metric" id="metricAccuracy"><span class="material-icons-round">analytics</span>—</span>
        </div>
      </div>
    </div>
  </div>

  <!-- ══ STEP 3: Convert ══ -->
  <div class="conv-card">
    <div class="conv-card-title">
      <span class="material-icons-round">bolt</span>
      3 — Convert &amp; export
    </div>

    <div class="progress-section" id="progressSection">
      <div class="progress-track" style="margin-bottom:.55rem">
        <div class="progress-fill" id="convProgressFill" style="width:0%"></div>
      </div>
      <div class="progress-row">
        <div class="progress-status" id="convStatus">Starting…</div>
        <div class="progress-label" id="convPct">0%</div>
      </div>
      <div class="progress-log" id="progressLog"></div>
    </div>

    <div class="result-section" id="resultSection">
      <div class="result-stat">
        <span class="result-stat-label">Model</span>
        <span class="result-stat-val" id="resModel">—</span>
      </div>
      <div class="result-stat">
        <span class="result-stat-label">Architecture</span>
        <span class="result-stat-val" id="resArch">—</span>
      </div>
      <div class="result-stat">
        <span class="result-stat-label">Tensors converted</span>
        <span class="result-stat-val" id="resTensors">—</span>
      </div>
      <div class="result-stat">
        <span class="result-stat-label">Shards created</span>
        <span class="result-stat-val" id="resShards">—</span>
      </div>
      <div class="result-stat">
        <span class="result-stat-label">Quantization</span>
        <span class="result-stat-val purple" id="resQuant">—</span>
      </div>
      <div class="result-stat">
        <span class="result-stat-label">Total output size</span>
        <span class="result-stat-val green" id="resSize">—</span>
      </div>
      <div class="result-stat" id="resSpeedRow" style="display:none">
        <span class="result-stat-label">Expected inference speed</span>
        <span class="result-stat-val green" id="resSpeed">—</span>
      </div>
      <div class="action-row">
        <button class="action-btn primary" onclick="downloadModel()">
          <span class="material-icons-round">download</span>
          Download .acc bundle
        </button>
        <button class="action-btn" onclick="saveToOPFSModel()" id="opfsBtn">
          <span class="material-icons-round">save</span>
          Save to browser cache
        </button>
      </div>
      <div style="font-size:.6rem;color:var(--muted);line-height:1.7">
        <strong>Download</strong> saves to a folder you can upload to your CDN.<br>
        <strong>Browser cache</strong> uses OPFS — instant load on next session for testing.
      </div>
    </div>

    <button class="conv-btn" id="convBtn" onclick="startConversion()">
      <span class="material-icons-round">auto_fix_high</span>
      Download &amp; Convert
    </button>
  </div>

  <div class="conv-info">
    <span class="material-icons-round">lock</span>
    <span>100% browser-native. No data is uploaded to any server. All downloading, conversion, quantization and caching happens entirely on your device.</span>
  </div>

</div>

<!-- ── FOOTER ── -->
<footer class="site-footer">
  <div class="footer-inner">
    <img class="footer-logo footer-logo-light"
      src="https://i.ibb.co/mV4rQV7B/Chat-GPT-Image-18-Feb-2026-08-42-07.png" alt="LocalLLM by Actalithic">
    <img class="footer-logo footer-logo-dark"
      src="https://i.ibb.co/tpSTrg7Z/whitelogo.png" alt="LocalLLM by Actalithic">
    <span class="footer-copy">© 2026 Actalithic · LocalLLM</span>
    <div class="footer-links">
      <a class="footer-link" href="index.html">LocalLLM</a>
      <span class="footer-sep">·</span>
      <a class="footer-link" href="blog.html">Blog</a>
      <span class="footer-sep">·</span>
      <a class="footer-link" href="https://bsky.app/profile/actalithic.bsky.social" target="_blank" rel="noopener">
        <svg viewBox="0 0 600 530" xmlns="http://www.w3.org/2000/svg"><path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z" fill="currentColor"/></svg>
        Bluesky
      </a>
      <span class="footer-sep">·</span>
      <a class="footer-link" href="https://github.com/actalithic" target="_blank" rel="noopener">GitHub</a>
    </div>
  </div>
</footer>

<script type="module">
import { convertSafetensors, downloadBundle, saveToOPFS } from './js/acc-converter.js';
import { toggleTheme } from './js/theme.js';
window.toggleTheme = toggleTheme;

// ── Theme ────────────────────────────────────────────────────────────────────
function applyLogos() {
  const d = document.documentElement.getAttribute('data-theme') === 'dark';
  document.querySelectorAll('.logo-light,.footer-logo-light').forEach(e => e.style.display = d ? 'none' : 'block');
  document.querySelectorAll('.logo-dark,.footer-logo-dark').forEach(e =>  e.style.display = d ? 'block' : 'none');
  const ic = document.getElementById('themeIcon');
  if (ic) ic.textContent = d ? 'light_mode' : 'dark_mode';
}
applyLogos();
new MutationObserver(applyLogos).observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

// ── State ────────────────────────────────────────────────────────────────────
let _activeModel   = null;   // selected MODELS entry
let _bundle        = null;
let _kernelsSrc    = null;
let _activePreset  = 'extreme';

fetch('./webgpu/kernels.wgsl').then(r => r.text()).then(t => { _kernelsSrc = t; }).catch(() => {});

// ── Model catalogue — these are the exact models LocalLLM ships ──────────────
const MODELS = [
  {
    id:          'llama-3.2-1b.acc',
    name:        'Llama 3.2 1B',
    creator:     'Meta',
    tier:        'Light',
    size:        '~0.5 GB',
    arch:        'llama',
    outputName:  'llama-3.2-1b',
    desc:        'Fastest model — great for all devices including mobile.',
    tags:        [['Light', 'green'], ['LLaMA 3', 'purple'], ['2 GB', 'blue']],
    // 1B bnb-4bit: single model.safetensors ~0.5 GB — fits in any browser's ArrayBuffer.
    // (3B bnb-4bit is still ~2 GB which OOMs on low-RAM devices; 1B is safe everywhere.)
    hfBase:      'https://huggingface.co/unsloth/Llama-3.2-1B-Instruct-bnb-4bit/resolve/main',
    hfWeights:   'model.safetensors',
    hfTokenizer: 'tokenizer.json',
  },
  {
    id:          'mistral-7b-instruct.acc',
    name:        'Mistral 7B',
    creator:     'Mistral AI',
    tier:        'Middle',
    size:        '~4 GB',
    arch:        'mistral',
    outputName:  'mistral-7b-instruct',
    desc:        'Well-rounded general-purpose model. Best balance of speed and quality.',
    tags:        [['Middle', 'amber'], ['Mistral', 'purple'], ['4 GB', 'blue']],
    // unsloth mirror is public (no login required); has model.safetensors.index.json
    hfBase:      'https://huggingface.co/unsloth/mistral-7b-instruct-v0.3/resolve/main',
    hfWeights:   'model.safetensors',
    hfTokenizer: 'tokenizer.json',
  },
  {
    id:          'deepseek-r1-8b.acc',
    name:        'DeepSeek R1 8B',
    creator:     'DeepSeek',
    tier:        'Advanced',
    size:        '~5 GB',
    arch:        'llama',
    outputName:  'deepseek-r1-8b',
    desc:        'Reasoning model with step-by-step thinking. Needs a powerful device.',
    tags:        [['Advanced', 'purple'], ['Reasoning', 'blue'], ['5 GB', 'amber']],
    hfBase:      'https://huggingface.co/deepseek-ai/DeepSeek-R1-Distill-Llama-8B/resolve/main',
    // No model.safetensors.index.json in this repo — shards are hardcoded here
    hfShards:    ['model-00001-of-000002.safetensors', 'model-00002-of-000002.safetensors'],
    hfWeights:   'model.safetensors',
    hfTokenizer: 'tokenizer.json',
  },
];

// ── Build model picker ────────────────────────────────────────────────────────
function buildModelPicker() {
  document.getElementById('modelPickerGrid').innerHTML = MODELS.map(m => `
    <div class="hf-model-card" data-mid="${m.id}" onclick="pickModel('${m.id}')">
      <div class="hf-card-name">${m.name}</div>
      <div class="hf-card-meta">
        <span>${m.creator}</span><span>·</span><span>${m.tier}</span><span>·</span><span>${m.size}</span>
      </div>
      <div class="hf-card-meta" style="margin-top:.2rem">
        ${m.tags.map(([t,c])=>`<span class="hf-card-tag ${c==='green'?'q4':c==='purple'?'acc':''}">${t}</span>`).join('')}
      </div>
      <div style="font-size:.63rem;color:var(--muted);margin-top:.35rem;line-height:1.5">${m.desc}</div>
    </div>
  `).join('');
}
buildModelPicker();

window.pickModel = function(id) {
  _activeModel = MODELS.find(m => m.id === id) || null;
  document.querySelectorAll('#modelPickerGrid .hf-model-card')
    .forEach(c => c.classList.toggle('selected', c.dataset.mid === id));
  // Update convert button label
  const btn = document.getElementById('convBtn');
  if (_activeModel) {
    btn.innerHTML = `<span class="material-icons-round">auto_fix_high</span> Download &amp; Convert ${_activeModel.name}`;
    btn.disabled = false;
  }
};

// ── Presets ──────────────────────────────────────────────────────────────────
const PRESETS = {
  extreme: {
    label: 'Extreme Speed', quant: 'q4', shardBytes: 536870912,
    speedEst: '15–80 tok/s depending on device',
    accuracyNote: 'ACC-optimised Q4 · ~98% quality · recommended',
    tags: [['Fastest', 'green'], ['Q4 ACC', 'purple'], ['Recommended', 'blue']],
    desc: 'Actalithic-optimised Q4 with per-block calibration — maximum inference speed. Recommended for all ACC models.',
  },
  balanced: {
    label: 'Balanced', quant: 'q8', shardBytes: 268435456,
    speedEst: '8–40 tok/s depending on device',
    accuracyNote: 'Q8 symmetric blocks · ~99.5% quality',
    tags: [['Balanced', 'amber'], ['Q8', 'purple'], ['High fidelity', 'blue']],
    desc: 'Q8 quantization — higher fidelity at moderate speed. Good for precise tasks.',
  },
  quality: {
    label: 'Max Quality', quant: 'f16', shardBytes: 268435456,
    speedEst: '5–20 tok/s depending on device',
    accuracyNote: 'F16 · near-lossless',
    tags: [['Near-lossless', 'green'], ['F16', 'purple'], ['2× size', 'amber']],
    desc: 'F16 half-precision — near-lossless accuracy when correctness matters most.',
  },
};

function buildPresets() {
  document.getElementById('presetGrid').innerHTML = Object.entries(PRESETS).map(([k, p]) => `
    <div class="preset-card ${k === _activePreset ? 'active' : ''}" data-preset="${k}" onclick="selectPreset('${k}')">
      <div class="preset-name">${p.label}</div>
      <div class="preset-desc">${p.desc}</div>
      <div class="preset-tags">${p.tags.map(([t,c])=>`<span class="preset-tag ${c}">${t}</span>`).join('')}</div>
    </div>
  `).join('');
}
buildPresets();

window.selectPreset = function(k) {
  _activePreset = k;
  const p = PRESETS[k];
  document.querySelectorAll('.preset-card').forEach(c => c.classList.toggle('active', c.dataset.preset === k));
  document.getElementById('quantMode').value  = p.quant;
  document.getElementById('shardSize').value  = String(p.shardBytes);
  document.getElementById('speedEstimateText').innerHTML =
    `<strong>${p.label}:</strong> ${p.speedEst} &nbsp;·&nbsp; ${p.accuracyNote}`;
  document.getElementById('speedEstimate').classList.add('visible');
  updateMetrics();
};
selectPreset('extreme');

function updateMetrics() {
  const q = document.getElementById('quantMode').value;
  const s = parseInt(document.getElementById('shardSize').value);
  const speedMap = { q4: '★★★★★ Extreme', q8: '★★★★☆ Fast', f16: '★★★☆☆ Moderate', f32: '★★☆☆☆ Slow' };
  const accMap   = { q4: '~98% accuracy',  q8: '~99.5% accuracy', f16: '~100% accuracy', f32: '100% accuracy' };
  document.getElementById('metricQuant').innerHTML    = `<span class="material-icons-round">compress</span>${q.toUpperCase()}`;
  document.getElementById('metricShard').innerHTML    = `<span class="material-icons-round">storage</span>${Math.round(s/1024/1024)} MB shards`;
  document.getElementById('metricSpeed').innerHTML    = `<span class="material-icons-round">speed</span>${speedMap[q]}`;
  document.getElementById('metricAccuracy').innerHTML = `<span class="material-icons-round">analytics</span>${accMap[q]}`;
  document.getElementById('metricSpeed').className    = 'opt-metric' + (q==='q4'?' hi':q==='q8'?' ok':'');
}

window.onExpertChange = function() {
  updateMetrics();
  _activePreset = null;
  document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
  document.getElementById('speedEstimate').classList.remove('visible');
};
window.toggleExpert = function() {
  document.getElementById('expertToggle').classList.toggle('open');
  document.getElementById('expertPanel').classList.toggle('open');
};

// ── Shard detection + streaming download + merge ─────────────────────────────
//
// Memory budget — one shard download in-flight at a time:
//
//  OLD v1: download ALL shards → keep all → merge  (peak = N×shard + output)
//  OLD v2: pre-alloc output → stream each shard directly in  (peak = 1 shard + output)
//          ✗ still OOMs because pre-allocating 6 GB for BF16 models fails outright.
//
//  NEW:    stream shard → extract ONLY tensor bytes (strip gaps) into compact slice
//          → null the stream buffer → next shard
//          → assemble final merged safetensors from compact slices, freeing each as we go
//
//  Peak ≈ 1 shard download  +  output buffer  (output = unavoidable, it's the payload).
//  We never pre-allocate the full raw-shard size upfront, so no 6 GB surprise.
//
// ?download=true forces HuggingFace to serve actual binary (not Xet/LFS pointer).
function hfUrl(base, fname) {
  return `${base}/${fname}?download=true`;
}

// ── Read safetensors header via a cheap 64 KB range request ──────────────────
async function fetchSafetensorsHeader(url) {
  // Step 1: fetch just 8 bytes to read the header length field
  const lenResp = await fetch(url, { headers: { Range: 'bytes=0-7' } });
  if (!lenResp.ok && lenResp.status !== 206) throw new Error(`HTTP ${lenResp.status}: ${url}`);
  const lenBuf    = new Uint8Array(await lenResp.arrayBuffer());
  const headerLen = new DataView(lenBuf.buffer).getUint32(0, true); // lo 32 bits

  // Step 2: fetch exactly the header bytes (never too small, never wasteful)
  const end      = 8 + headerLen - 1;
  const hdrResp  = await fetch(url, { headers: { Range: `bytes=8-${end}` } });
  if (!hdrResp.ok && hdrResp.status !== 206) throw new Error(`HTTP ${hdrResp.status}: ${url}`);
  const hdrBytes = new Uint8Array(await hdrResp.arrayBuffer());
  const header   = JSON.parse(new TextDecoder().decode(hdrBytes));
  return { header, dataStart: 8 + headerLen };
}

// ── Stream one shard → return compact Uint8Array of tensor bytes only ─────────
// Gaps/alignment padding between tensors are skipped — output is tightly packed.
// `totalDl` is a shared {bytes} counter for cross-shard progress display.
async function streamShardCompact(url, header, dataStart, si, shardTotal, onStatus, totalDl) {
  const regions = Object.entries(header)
    .filter(([n]) => n !== '__metadata__')
    .map(([name, meta]) => ({
      name,
      dtype:     meta.dtype,
      shape:     meta.shape,
      fileStart: meta.data_offsets[0],
      byteLen:   meta.data_offsets[1] - meta.data_offsets[0],
    }))
    .sort((a, b) => a.fileStart - b.fileStart);

  // Pre-allocate compact output (tensor bytes only, no padding)
  const compactSize = regions.reduce((s, r) => s + r.byteLen, 0);
  let compactData;
  try { compactData = new Uint8Array(compactSize); }
  catch(e) { throw new Error(`Shard too large for browser memory (needs ${fmtBytes(compactSize)}). Try a desktop browser with more RAM.`); }

  // Assign compact write offsets
  let compactOff = 0;
  for (const r of regions) {
    r.compactStart = compactOff;
    compactOff    += r.byteLen;
  }

  // Stream from where the tensor data begins (skip header we already have)
  const resp = await fetch(url, { headers: { Range: `bytes=${dataStart}-` } });
  if (!resp.ok && resp.status !== 206) throw new Error(`HTTP ${resp.status}: ${url}`);
  const contentLen = parseInt(resp.headers.get('content-length') || '0');
  const reader = resp.body.getReader();

  let streamPos     = 0;  // position in tensor-data stream
  let regionIdx     = 0;
  let regionWritten = 0;
  let shardLoaded   = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    shardLoaded     += value.length;
    totalDl.bytes   += value.length;

    const pct = contentLen > 0 ? Math.round(shardLoaded / contentLen * 100) : 0;
    setDlStatus('loading',
      `Shard ${si + 1}/${shardTotal}: ${fmtBytes(shardLoaded)}${contentLen ? ' / ' + fmtBytes(contentLen) + ' (' + pct + '%)' : ''} · total ${fmtBytes(totalDl.bytes)}`,
      true, pct);
    onStatus(`Streaming shard ${si + 1}/${shardTotal} — ${fmtBytes(shardLoaded)}`);

    let cp = 0;
    while (cp < value.length && regionIdx < regions.length) {
      const r = regions[regionIdx];

      // Skip alignment padding before this region
      if (streamPos < r.fileStart) {
        const skip = Math.min(r.fileStart - streamPos, value.length - cp);
        streamPos += skip; cp += skip;
        continue;
      }

      // Copy tensor bytes directly into compact buffer
      const toCopy = Math.min(r.byteLen - regionWritten, value.length - cp);
      compactData.set(value.subarray(cp, cp + toCopy), r.compactStart + regionWritten);
      regionWritten += toCopy;
      streamPos     += toCopy;
      cp            += toCopy;

      if (regionWritten >= r.byteLen) { regionIdx++; regionWritten = 0; }
    }
    // Any tail bytes past the last region are padding — safely ignored.
  }

  // Build tensor manifest with compact offsets
  const tensors = regions.map(r => ({
    name:  r.name,
    dtype: r.dtype,
    shape: r.shape,
    start: r.compactStart,
    end:   r.compactStart + r.byteLen,
  }));

  return { tensors, data: compactData };
  // `compactData` is the only allocation that survives.
  // The ReadableStream and its internal buffers are now eligible for GC.
}

// ── Main entry ────────────────────────────────────────────────────────────────
async function loadModelWeights(m, onStatus) {
  const base = m.hfBase;

  // 1. Resolve shard list
  let shardFiles = m.hfShards || null;
  if (!shardFiles) {
    try {
      const idxResp = await fetch(hfUrl(base, 'model.safetensors.index.json'));
      if (idxResp.ok) {
        const idx  = await idxResp.json();
        shardFiles = [...new Set(Object.values(idx.weight_map))].sort();
      }
    } catch {}
  }

  // 2. Single-file fast path — pre-alloc final buffer, stream directly into it
  if (!shardFiles || shardFiles.length <= 1) {
    const fname = shardFiles?.[0] || m.hfWeights || 'model.safetensors';
    onStatus(`Reading ${fname} header…`);
    const singleUrl = hfUrl(base, fname);
    const { header: sh, dataStart: sd } = await fetchSafetensorsHeader(singleUrl);

    // Build header JSON now so we know its size, then allocate ONE buffer for everything
    const compactSize = Object.entries(sh)
      .filter(([n]) => n !== '__metadata__')
      .reduce((s, [, m]) => s + (m.data_offsets[1] - m.data_offsets[0]), 0);
    const { hdrBytes: shHdrBytes, padLen: shPadLen, hdrObj: shHdrObj } =
      buildSafetensorsHeader(sh);
    const shTotalBytes = 8 + shPadLen + compactSize;
    onStatus(`Allocating ${fmtBytes(shTotalBytes)} buffer…`);
    let shOut;
    try { shOut = new Uint8Array(shTotalBytes); }
    catch(e) { throw new Error(`Model too large for browser memory (needs ${fmtBytes(shTotalBytes)}). Try a smaller model or use a desktop browser with more RAM.`); }
    const shDv  = new DataView(shOut.buffer);
    shDv.setUint32(0, shPadLen, true);
    shDv.setUint32(4, 0,        true);
    shOut.set(shHdrBytes, 8);
    for (let i = 0; i < shPadLen - shHdrBytes.length; i++)
      shOut[8 + shHdrBytes.length + i] = 0x20;

    // Stream tensor data directly into shOut past the header — zero extra allocation
    const shDataView = new Uint8Array(shOut.buffer, 8 + shPadLen, compactSize);
    onStatus(`Downloading ${fname}…`);
    await streamShardIntoView(singleUrl, sh, sd, shDataView, 0, 1, onStatus);
    setDlStatus('ok', `${fname} downloaded (${fmtBytes(shTotalBytes)})`, false, 100);
    return shOut.buffer;
  }

  // 3. Multi-shard: read headers first (one 64 KB range request each)
  onStatus(`Reading ${shardFiles.length} shard headers…`);
  setDlStatus('loading', `Reading shard headers (${shardFiles.length} files)…`, false, 0);
  const shardHeaders = [];
  for (const fname of shardFiles) {
    const { header, dataStart } = await fetchSafetensorsHeader(hfUrl(base, fname));
    shardHeaders.push({ fname, header, dataStart });
  }

  // 4. Stream each shard → compact slice → free stream; one shard live at a time
  const shardResults = [];
  const totalDl      = { bytes: 0 };
  for (let si = 0; si < shardHeaders.length; si++) {
    const { fname, header, dataStart } = shardHeaders[si];
    onStatus(`Downloading shard ${si + 1}/${shardHeaders.length}: ${fname}`);
    const result = await streamShardCompact(
      hfUrl(base, fname), header, dataStart,
      si, shardHeaders.length, onStatus, totalDl
    );
    shardResults.push(result);
    onStatus(`Shard ${si + 1}/${shardHeaders.length} done — ${fmtBytes(result.data.byteLength)} tensor data`);
    // result.data is compact (tensor bytes only). The raw download stream is gone.
  }

  // 5. Compute total compact data size from shard compact slices
  onStatus('Building merged safetensors buffer…');
  let dataOffset = 0;
  const mergedHdrObj = {};
  for (const { tensors } of shardResults) {
    for (const t of tensors) {
      const len = t.end - t.start;
      mergedHdrObj[t.name] = { dtype: t.dtype, shape: t.shape,
        data_offsets: [dataOffset, dataOffset + len] };
      dataOffset += len;
    }
  }

  const mHdrJson  = JSON.stringify(mergedHdrObj);
  const mHdrBytes = new TextEncoder().encode(mHdrJson);
  const mPad      = (8 - (mHdrBytes.length % 8)) % 8;
  const mPadLen   = mHdrBytes.length + mPad;
  const totalBytes = 8 + mPadLen + dataOffset;

  // 6. Allocate ONE output buffer, copy compact shard data in, free each slice immediately
  onStatus(`Allocating ${fmtBytes(totalBytes)} output buffer…`);
  let out;
  try { out = new Uint8Array(totalBytes); }
  catch(e) { throw new Error(`Model too large for browser memory (needs ${fmtBytes(totalBytes)}). Try a smaller model or use a desktop browser with more RAM.`); }
  const dv  = new DataView(out.buffer);
  dv.setUint32(0, mPadLen, true);
  dv.setUint32(4, 0,       true);
  out.set(mHdrBytes, 8);
  for (let i = 0; i < mPad; i++) out[8 + mHdrBytes.length + i] = 0x20;

  let writeOff = 8 + mPadLen;
  for (let si = 0; si < shardResults.length; si++) {
    out.set(shardResults[si].data, writeOff);
    writeOff += shardResults[si].data.byteLength;
    shardResults[si].data = null;  // ← free compact slice immediately after copy
  }

  setDlStatus('ok', `${shardHeaders.length} shards merged — ${fmtBytes(totalBytes)}`, false, 100);
  return out.buffer;
}

// ── Build safetensors header bytes from a raw shard header ───────────────────
// Recomputes contiguous data_offsets (stripping gaps) and returns encoded bytes.
function buildSafetensorsHeader(srcHeader) {
  let off = 0;
  const hdrObj = {};
  const regions = Object.entries(srcHeader)
    .filter(([n]) => n !== '__metadata__')
    .map(([name, meta]) => ({ name, dtype: meta.dtype, shape: meta.shape,
      byteLen: meta.data_offsets[1] - meta.data_offsets[0] }))
    .sort((a, b) => 0); // stable — order preserved from header
  for (const r of regions) {
    hdrObj[r.name] = { dtype: r.dtype, shape: r.shape,
      data_offsets: [off, off + r.byteLen] };
    off += r.byteLen;
  }
  const hdrJson  = JSON.stringify(hdrObj);
  const hdrBytes = new TextEncoder().encode(hdrJson);
  const pad      = (8 - (hdrBytes.length % 8)) % 8;
  const padLen   = hdrBytes.length + pad;
  return { hdrBytes, padLen, hdrObj };
}

// ── Stream tensor data from one shard directly into a pre-allocated Uint8Array ─
// `view` must be exactly compactSize bytes (no header, just tensor data).
// Chunks land directly in `view` — no intermediate buffer.
async function streamShardIntoView(url, header, dataStart, view, si, shardTotal, onStatus) {
  const regions = Object.entries(header)
    .filter(([n]) => n !== '__metadata__')
    .map(([name, meta]) => ({
      name,
      fileStart: meta.data_offsets[0],
      byteLen:   meta.data_offsets[1] - meta.data_offsets[0],
    }))
    .sort((a, b) => a.fileStart - b.fileStart);

  // Map each tensor name → its compact write offset in view
  const writeOffset = {};
  let compactOff = 0;
  for (const r of regions) {
    writeOffset[r.name] = compactOff;
    compactOff += r.byteLen;
  }

  const resp = await fetch(url, { headers: { Range: `bytes=${dataStart}-` } });
  if (!resp.ok && resp.status !== 206) throw new Error(`HTTP ${resp.status}: ${url}`);
  const contentLen = parseInt(resp.headers.get('content-length') || '0');
  const reader = resp.body.getReader();

  let streamPos = 0, regionIdx = 0, regionWritten = 0, loaded = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    loaded += value.length;
    const pct = contentLen > 0 ? Math.round(loaded / contentLen * 100) : 0;
    setDlStatus('loading',
      `Downloading: ${fmtBytes(loaded)}${contentLen ? ' / ' + fmtBytes(contentLen) + ' (' + pct + '%)' : ''}`,
      true, pct);
    onStatus(`Downloading — ${fmtBytes(loaded)}`);

    let cp = 0;
    while (cp < value.length && regionIdx < regions.length) {
      const r = regions[regionIdx];
      if (streamPos < r.fileStart) {
        const skip = Math.min(r.fileStart - streamPos, value.length - cp);
        streamPos += skip; cp += skip; continue;
      }
      const dst     = writeOffset[r.name] + regionWritten;
      const toCopy  = Math.min(r.byteLen - regionWritten, value.length - cp);
      view.set(value.subarray(cp, cp + toCopy), dst);
      regionWritten += toCopy; streamPos += toCopy; cp += toCopy;
      if (regionWritten >= r.byteLen) { regionIdx++; regionWritten = 0; }
    }
  }
}

function setDlStatus(type, text, showBar = false, pct = 0) {
  const el = document.getElementById('dlStatus');
  el.style.display = 'flex';
  el.className = 'hf-status visible' + (type === 'ok' ? ' ok' : type === 'err' ? ' err' : '');
  document.getElementById('dlStatusIcon').textContent =
    type === 'ok' ? 'check_circle' : type === 'err' ? 'error' : 'downloading';
  document.getElementById('dlStatusText').textContent = text;
  const bar = document.getElementById('dlProgress');
  bar.style.display = showBar ? 'block' : 'none';
  if (showBar) document.getElementById('dlFill').style.width = pct + '%';
}

// ── Main conversion flow ──────────────────────────────────────────────────────
window.startConversion = async function() {
  if (!_activeModel) {
    alert('Please select a model first (Step 1).');
    return;
  }

  const btn    = document.getElementById('convBtn');
  const quant  = document.getElementById('quantMode').value;
  const shard  = parseInt(document.getElementById('shardSize').value);
  const preset = _activePreset ? PRESETS[_activePreset] : null;

  btn.disabled = true;
  btn.innerHTML = '<span class="material-icons-round">hourglass_empty</span> Working…';
  document.getElementById('progressSection').classList.add('visible');
  document.getElementById('resultSection').classList.remove('visible');
  document.getElementById('progressLog').innerHTML = '';

  function onConvProgress(pct, msg) {
    document.getElementById('convProgressFill').style.width = pct + '%';
    document.getElementById('convStatus').textContent = msg;
    document.getElementById('convPct').textContent = pct + '%';
    const log  = document.getElementById('progressLog');
    const line = document.createElement('div'); line.className = 'log-line';
    line.innerHTML = `<span class="log-pct">${pct}%</span><span class="log-msg">${msg}</span>`;
    log.appendChild(line); log.scrollTop = log.scrollHeight;
  }

  try {
    const m = _activeModel;

    // ── Step A: Download weights (auto-detects single vs multi-shard) ───────
    onConvProgress(1, `Detecting ${m.name} model files…`);
    let weightsBuffer;
    try {
      weightsBuffer = await loadModelWeights(m, (msg) => onConvProgress(2, msg));
    } catch(e) {
      throw new Error(`Download failed: ${e.message}`);
    }
    const dlSize = fmtBytes(weightsBuffer.byteLength);
    setDlStatus('ok', `${m.name} downloaded (${dlSize})`, false, 100);
    onConvProgress(40, `Downloaded ${dlSize} — fetching tokenizer…`);

    // ── Step B: Tokenizer ───────────────────────────────────────────────────
    let tokenizerJson = null;
    try {
      const tr = await fetch(hfUrl(m.hfBase, m.hfTokenizer));
      if (tr.ok) tokenizerJson = await tr.text();
    } catch {}

    onConvProgress(42, 'Converting to .acc format…');

    // ── Step C: Convert ─────────────────────────────────────────────────────
    _bundle = await convertSafetensors(weightsBuffer, {
      quantMode:       quant,
      shardSizeBytes:  shard,
      onProgress:      (pct, msg) => onConvProgress(42 + Math.round(pct * 0.56), msg),
      configOverrides: { arch: m.arch },
      tokenizerJson,
      kernelsSrc:      _kernelsSrc,
      optimized:       true,
      blockSize:       quant === 'q4' ? 128 : 64,
      calibrateBlocks: true,
    });
    weightsBuffer = null; // free RAM

    // ── Show results ────────────────────────────────────────────────────────
    const manifest = _bundle.manifest;
    const config   = _bundle.config;
    document.getElementById('resModel').textContent    = m.name;
    document.getElementById('resArch').innerHTML       = `${config.arch || m.arch} <span class="arch-badge">${manifest.quant?.toUpperCase()}</span>`;
    document.getElementById('resTensors').textContent  = manifest.tensor_count;
    document.getElementById('resShards').textContent   = manifest.num_shards;
    document.getElementById('resQuant').textContent    = manifest.quant?.toUpperCase() + (preset?.accuracyNote ? ' — ' + preset.accuracyNote : '');
    document.getElementById('resSize').textContent     = fmtBytes(_bundle.shards.reduce((s, b) => s + b.byteLength, 0));
    if (preset?.speedEst) {
      document.getElementById('resSpeed').textContent = preset.speedEst;
      document.getElementById('resSpeedRow').style.display = 'flex';
    } else {
      document.getElementById('resSpeedRow').style.display = 'none';
    }
    document.getElementById('resultSection').classList.add('visible');
    onConvProgress(100, 'Done! Download or save to browser cache below.');
    btn.innerHTML = '<span class="material-icons-round">check_circle</span> Conversion complete!';

  } catch (err) {
    onConvProgress(0, 'Error: ' + err.message);
    setDlStatus('err', err.message, false, 0);
    console.error(err);
    btn.disabled = false;
    btn.innerHTML = `<span class="material-icons-round">auto_fix_high</span> Retry — Download &amp; Convert ${_activeModel?.name || ''}`;
  }
};

window.downloadModel = async function() {
  if (!_bundle) return;
  try { await downloadBundle(_bundle, _activeModel?.outputName || 'model'); }
  catch(e) { if (e.name !== 'AbortError') alert('Download failed: ' + e.message); }
};

window.saveToOPFSModel = async function() {
  if (!_bundle) return;
  const btn = document.getElementById('opfsBtn');
  btn.disabled = true;
  btn.innerHTML = '<span class="material-icons-round">hourglass_empty</span> Saving…';
  try {
    await saveToOPFS(_bundle, _activeModel?.outputName || 'model');
    btn.innerHTML = '<span class="material-icons-round">check_circle</span> Saved to cache!';
    btn.style.color = 'var(--green)';
  } catch(e) {
    alert('OPFS save failed: ' + e.message);
    btn.disabled = false;
    btn.innerHTML = '<span class="material-icons-round">save</span> Save to browser cache';
  }
};

function fmtBytes(b) {
  if (b >= 1e9) return (b / 1e9).toFixed(2) + ' GB';
  if (b >= 1e6) return (b / 1e6).toFixed(1) + ' MB';
  if (b >= 1e3) return (b / 1e3).toFixed(0) + ' KB';
  return b + ' B';
}
</script>
</body>
</html>
