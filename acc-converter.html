<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>ACC Converter — Actalithic</title>
<link rel="icon" type="image/png" href="https://i.ibb.co/DfYLtMhQ/favicon.png">
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
<link rel="stylesheet" href="css/style.css">
<script>(function(){var s=localStorage.getItem('llm-theme');document.documentElement.setAttribute('data-theme',s||'dark');})()</script>
<style>
.converter-wrap{
  width:100%;max-width:760px;margin:0 auto;
  padding:2rem 1.25rem 3rem;
  display:flex;flex-direction:column;gap:1.75rem;
}
@media(min-width:600px){.converter-wrap{padding:2.5rem 1.75rem 3.5rem}}
@media(min-width:840px){.converter-wrap{padding:3rem 2rem 4rem}}

.conv-card{
  background:var(--bg2);border:1px solid var(--border);
  border-radius:10px;padding:1.5rem 1.75rem;
  display:flex;flex-direction:column;gap:1.1rem;
}
.conv-card-title{
  font-family:'Syne',sans-serif;font-weight:700;font-size:1rem;
  color:var(--ink);display:flex;align-items:center;gap:.55rem;
}
.conv-card-title .material-icons-round{font-size:18px;color:var(--purple)}
.conv-card-sub{font-size:.72rem;color:var(--muted);line-height:1.7;margin-top:-.25rem}

/* Source tabs */
.source-tabs{
  display:flex;border:1px solid var(--border);border-radius:6px;overflow:hidden;
  background:var(--bg);
}
.source-tab{
  flex:1;padding:.6rem .75rem;font-family:'DM Mono',monospace;font-size:.72rem;
  background:transparent;border:none;color:var(--muted);cursor:pointer;
  transition:all .15s;display:flex;align-items:center;justify-content:center;gap:.4rem;
  border-right:1px solid var(--border);
}
.source-tab:last-child{border-right:none}
.source-tab.active{background:var(--ink);color:var(--accent-inv)}
.source-tab .material-icons-round{font-size:14px}

/* HF catalogue */
.hf-catalogue-label{font-size:.62rem;color:var(--muted);text-transform:uppercase;letter-spacing:.08em}
.hf-model-grid{
  display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:.6rem;
}
.hf-model-card{
  border:1.5px solid var(--border);border-radius:8px;padding:.9rem 1rem;
  cursor:pointer;transition:all .15s;background:var(--bg);
  display:flex;flex-direction:column;gap:.35rem;
  -webkit-tap-highlight-color:transparent;
}
.hf-model-card:hover{border-color:var(--purple);background:var(--purple-bg)}
.hf-model-card.selected{border-color:var(--purple);background:var(--purple-bg)}
.hf-model-card.selected .hf-card-name{color:var(--purple)}
.hf-card-name{font-size:.85rem;color:var(--ink);font-weight:500;line-height:1.3}
.hf-card-meta{font-size:.6rem;color:var(--muted);display:flex;align-items:center;gap:.4rem;flex-wrap:wrap}
.hf-card-tag{
  font-size:.52rem;padding:1px 6px;border-radius:20px;
  border:1px solid var(--border);color:var(--muted);background:var(--bg3);
  white-space:nowrap;
}
.hf-card-tag.acc{border-color:var(--purple);color:var(--purple);background:var(--purple-bg)}
.hf-card-tag.q4{border-color:var(--green-dim);color:var(--green);background:var(--green-bg)}

.hf-custom-row{display:flex;gap:.5rem;align-items:flex-end}
.hf-custom-input{
  flex:1;font-family:'DM Mono',monospace;font-size:.78rem;
  padding:.55rem .85rem;border-radius:6px;
  background:var(--bg);border:1px solid var(--border2);color:var(--ink);
  outline:none;transition:border-color .15s;
}
.hf-custom-input:focus{border-color:var(--purple);box-shadow:0 0 0 2px rgba(102,51,187,.12)}
.hf-load-btn{
  font-family:'Syne',sans-serif;font-weight:700;font-size:.75rem;
  padding:.55rem 1.1rem;border-radius:6px;border:none;cursor:pointer;
  background:var(--purple);color:#fff;display:flex;align-items:center;gap:.35rem;
  white-space:nowrap;transition:all .15s;flex-shrink:0;
}
.hf-load-btn:hover{opacity:.85;transform:translateY(-1px)}
.hf-load-btn:disabled{opacity:.4;cursor:not-allowed;transform:none}
.hf-load-btn .material-icons-round{font-size:15px}

.hf-status{
  font-size:.7rem;color:var(--muted);display:none;
  align-items:center;gap:.5rem;
  padding:.65rem .85rem;background:var(--bg);border:1px solid var(--border);border-radius:6px;
  line-height:1.6;
}
.hf-status.visible{display:flex}
.hf-status .material-icons-round{font-size:15px;flex-shrink:0}
.hf-status.ok{color:var(--green);border-color:var(--green-dim);background:var(--green-bg)}
.hf-status.err{color:var(--red);border-color:var(--red-dim);background:var(--red-bg)}
.hf-dl-progress{width:100%;height:3px;background:var(--border);border-radius:2px;overflow:hidden;margin-top:.35rem}
.hf-dl-fill{height:100%;background:var(--purple);width:0%;transition:width .3s}

/* File drop */
.drop-zone{
  border:2px dashed var(--border2);border-radius:8px;
  padding:2.75rem 1rem;text-align:center;
  cursor:pointer;transition:all .2s;background:var(--bg);
  display:flex;flex-direction:column;align-items:center;gap:.65rem;
}
.drop-zone:hover,.drop-zone.drag-over{border-color:var(--purple);background:var(--purple-bg)}
.drop-zone .material-icons-round{font-size:2.5rem;color:var(--muted)}
.drop-zone.drag-over .material-icons-round{color:var(--purple)}
.drop-label{font-size:.82rem;color:var(--muted)}
.drop-hint{font-size:.65rem;color:var(--border2)}
.drop-file-name{
  font-size:.75rem;color:var(--green);font-weight:500;
  display:flex;align-items:center;gap:.35rem;
  padding:.4rem .75rem;background:var(--green-bg);
  border-radius:20px;border:1px solid var(--green-dim);
}

/* Presets */
.preset-grid{
  display:grid;grid-template-columns:repeat(auto-fill,minmax(170px,1fr));gap:.65rem;
}
.preset-card{
  border:1.5px solid var(--border);border-radius:8px;padding:1rem 1.1rem;
  cursor:pointer;transition:all .15s;background:var(--bg);
  display:flex;flex-direction:column;gap:.35rem;
  -webkit-tap-highlight-color:transparent;
}
.preset-card:hover{border-color:var(--purple);background:var(--purple-bg)}
.preset-card.active{border-color:var(--purple);background:var(--purple-bg)}
.preset-card.active .preset-name{color:var(--purple)}
.preset-name{font-family:'Syne',sans-serif;font-weight:700;font-size:.88rem;color:var(--ink)}
.preset-desc{font-size:.65rem;color:var(--muted);line-height:1.6}
.preset-tags{display:flex;gap:.35rem;flex-wrap:wrap;margin-top:.25rem}
.preset-tag{
  font-size:.5rem;padding:1px 6px;border-radius:20px;
  border:1px solid var(--border);color:var(--muted);background:var(--bg3);
}
.preset-tag.green{border-color:var(--green-dim);color:var(--green);background:var(--green-bg)}
.preset-tag.purple{border-color:var(--purple-dim);color:var(--purple);background:var(--purple-bg)}
.preset-tag.blue{border-color:var(--blue);color:var(--blue);background:var(--blue-bg)}
.preset-tag.amber{border-color:var(--amber-dim);color:var(--amber);background:var(--amber-bg)}

.speed-estimate{
  display:none;align-items:center;gap:.6rem;
  padding:.65rem 1rem;background:var(--green-bg);
  border:1px solid var(--green-dim);border-radius:6px;
  font-size:.7rem;color:var(--green);line-height:1.6;
}
.speed-estimate.visible{display:flex}
.speed-estimate .material-icons-round{font-size:16px;flex-shrink:0}

/* Expert */
.expert-toggle{
  font-size:.68rem;color:var(--muted);cursor:pointer;
  display:flex;align-items:center;gap:.35rem;
  transition:color .15s;user-select:none;width:fit-content;
}
.expert-toggle:hover{color:var(--ink)}
.expert-toggle .material-icons-round.chevron{font-size:14px;transition:transform .2s}
.expert-toggle.open .material-icons-round.chevron{transform:rotate(180deg)}
.expert-panel{display:none;flex-direction:column;gap:1rem;padding-top:.25rem}
.expert-panel.open{display:flex}

.options-grid{display:grid;grid-template-columns:1fr 1fr;gap:1rem}
@media(max-width:480px){.options-grid{grid-template-columns:1fr}}
.opt-field{display:flex;flex-direction:column;gap:.4rem}
.opt-label{font-size:.62rem;color:var(--muted);text-transform:uppercase;letter-spacing:.08em}
.opt-select,.opt-input{
  font-family:'DM Mono',monospace;font-size:.78rem;
  padding:.55rem .85rem;border-radius:6px;
  background:var(--bg);border:1px solid var(--border2);color:var(--ink);
  outline:none;transition:border-color .15s;
}
.opt-select:focus,.opt-input:focus{border-color:var(--purple)}

.tok-drop{
  border:1.5px dashed var(--border);border-radius:6px;
  padding:.65rem .85rem;font-size:.72rem;color:var(--muted);
  cursor:pointer;transition:all .15s;background:var(--bg);
  display:flex;align-items:center;gap:.4rem;
}
.tok-drop:hover{border-color:var(--purple);color:var(--purple);background:var(--purple-bg)}
.tok-drop.loaded{border-color:var(--green);color:var(--green);background:var(--green-bg)}

.opt-metrics{
  display:flex;gap:.45rem;flex-wrap:wrap;padding:.6rem .85rem;
  background:var(--bg3);border-radius:6px;border:1px solid var(--border);font-size:.65rem;
}
.opt-metric{
  display:flex;align-items:center;gap:.3rem;color:var(--muted);
  padding:2px 8px;border-radius:20px;border:1px solid var(--border);background:var(--bg);
  white-space:nowrap;
}
.opt-metric.ok{color:var(--green);border-color:var(--green-dim);background:var(--green-bg)}
.opt-metric.hi{color:var(--purple);border-color:var(--purple-dim);background:var(--purple-bg)}
.opt-metric .material-icons-round{font-size:11px}

/* Convert button */
.conv-btn{
  width:100%;padding:1rem;
  font-family:'Syne',sans-serif;font-weight:700;font-size:.92rem;
  letter-spacing:.04em;border-radius:8px;
  background:var(--accent);color:var(--accent-inv);border:none;
  cursor:pointer;transition:all .18s;
  display:flex;align-items:center;justify-content:center;gap:.5rem;min-height:52px;
}
.conv-btn:hover{opacity:.88;transform:translateY(-2px);box-shadow:0 6px 24px var(--shadow-lg)}
.conv-btn:active{transform:scale(.97);box-shadow:none}
.conv-btn:disabled{opacity:.4;cursor:not-allowed;transform:none;box-shadow:none}

/* Progress */
.progress-section{display:none}
.progress-section.visible{display:block}
.progress-log{
  font-size:.65rem;color:var(--muted);
  max-height:160px;overflow-y:auto;
  border:1px solid var(--border);border-radius:6px;
  padding:.6rem .85rem;background:var(--bg);
  display:flex;flex-direction:column;gap:.2rem;margin-top:.85rem;
}
.log-line{display:flex;gap:.5rem;align-items:baseline}
.log-pct{color:var(--purple);flex-shrink:0;width:3.2em;text-align:right;font-weight:500}
.log-msg{color:var(--ink2);line-height:1.5}

/* Results */
.result-section{display:none}
.result-section.visible{display:flex;flex-direction:column;gap:.75rem}
.result-stat{
  display:flex;justify-content:space-between;align-items:center;
  padding:.55rem 0;border-bottom:1px solid var(--border);font-size:.75rem;
}
.result-stat:last-of-type{border-bottom:none}
.result-stat-label{color:var(--muted)}
.result-stat-val{color:var(--ink);font-weight:500}
.result-stat-val.green{color:var(--green)}
.result-stat-val.purple{color:var(--purple)}

.action-row{display:flex;gap:.65rem;flex-wrap:wrap;margin-top:.25rem}
.action-btn{
  flex:1;min-width:150px;padding:.8rem .5rem;
  font-family:'Syne',sans-serif;font-weight:700;font-size:.78rem;
  border-radius:8px;border:1.5px solid var(--border2);
  background:var(--bg2);color:var(--ink);cursor:pointer;
  display:flex;align-items:center;justify-content:center;gap:.4rem;transition:all .15s;
}
.action-btn:hover{border-color:var(--purple);color:var(--purple);background:var(--purple-bg)}
.action-btn.primary{background:var(--accent);color:var(--accent-inv);border-color:var(--accent)}
.action-btn.primary:hover{opacity:.85;border-color:var(--accent)}
.action-btn .material-icons-round{font-size:16px}

.conv-info{
  background:var(--blue-bg);border:1px solid var(--blue);
  border-radius:8px;padding:.8rem 1rem;font-size:.7rem;
  color:var(--blue);display:flex;gap:.55rem;align-items:flex-start;line-height:1.7;
}
.conv-info .material-icons-round{font-size:15px;flex-shrink:0;margin-top:1px}

.arch-badge{
  font-size:.6rem;padding:2px 7px;border-radius:20px;
  border:1px solid var(--purple);color:var(--purple);
  background:var(--purple-bg);font-weight:500;display:inline-block;margin-left:.4rem;
}
.conv-page-title{
  font-family:'Syne',sans-serif;font-weight:800;
  font-size:clamp(1.5rem,6vw,2.2rem);letter-spacing:-.04em;
  color:var(--ink);line-height:1.1;
}
.conv-page-title span{color:var(--purple)}
.conv-page-sub{
  font-size:.78rem;color:var(--muted);line-height:1.8;margin-top:.5rem;max-width:540px;
}
</style>
</head>
<body>
<!-- ── HEADER ── -->
<header>
  <div class="header-brand">
    <img class="logo-img logo-light" src="https://i.ibb.co/mV4rQV7B/Chat-GPT-Image-18-Feb-2026-08-42-07.png" alt="LocalLLM by Actalithic">
    <img class="logo-img logo-dark"  src="https://i.ibb.co/tpSTrg7Z/whitelogo.png" alt="LocalLLM by Actalithic">
  </div>
  <div class="header-right">
    <a class="icon-btn" href="index.html" title="LocalLLM"><span class="material-icons-round">home</span></a>
    <a class="icon-btn bsky" href="https://bsky.app/profile/actalithic.bsky.social" target="_blank" rel="noopener" title="Bluesky">
      <svg viewBox="0 0 600 530" xmlns="http://www.w3.org/2000/svg"><path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z" fill="currentColor"/></svg>
    </a>
    <button class="icon-btn" onclick="toggleTheme()" title="Toggle theme">
      <span class="material-icons-round" id="themeIcon">light_mode</span>
    </button>
  </div>
</header>

<div class="converter-wrap">

  <div>
    <div class="conv-page-title">.acc <span>Converter</span></div>
    <div class="conv-page-sub">
      Admin tool — pick a model, choose an optimization, and convert. Weights download automatically. Nothing leaves your device.
    </div>
  </div>

  <!-- ══ STEP 1: Pick model ══ -->
  <div class="conv-card">
    <div class="conv-card-title">
      <span class="material-icons-round">model_training</span>
      1 — Choose model
    </div>
    <div class="conv-card-sub">Select which model to compile. Weights will download automatically from HuggingFace when you hit Convert.</div>
    <div class="hf-model-grid" id="modelPickerGrid"></div>

    <!-- Download status — hidden until Convert is pressed -->
    <div class="hf-status" id="dlStatus" style="display:none">
      <div style="flex:1">
        <div style="display:flex;align-items:center;gap:.5rem">
          <span class="material-icons-round" id="dlStatusIcon" style="font-size:15px">downloading</span>
          <span id="dlStatusText">Downloading…</span>
        </div>
        <div class="hf-dl-progress" id="dlProgress">
          <div class="hf-dl-fill" id="dlFill"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ══ STEP 2: Preset ══ -->
  <div class="conv-card">
    <div class="conv-card-title">
      <span class="material-icons-round">auto_fix_high</span>
      2 — Optimization
    </div>
    <div class="conv-card-sub">Choose how the model is quantized. Extreme Speed is recommended for all ACC models.</div>

    <div class="preset-grid" id="presetGrid"></div>

    <div class="speed-estimate" id="speedEstimate">
      <span class="material-icons-round">bolt</span>
      <div id="speedEstimateText"></div>
    </div>

    <!-- Expert options (collapsed by default) -->
    <div style="display:flex;flex-direction:column;gap:.75rem">
      <div class="expert-toggle" id="expertToggle" onclick="toggleExpert()">
        <span class="material-icons-round chevron">expand_more</span>
        <span class="material-icons-round" style="font-size:13px">tune</span>
        Advanced options
      </div>
      <div class="expert-panel" id="expertPanel">
        <div class="options-grid">
          <div class="opt-field">
            <div class="opt-label">Quantization</div>
            <select class="opt-select" id="quantMode" onchange="onExpertChange()">
              <option value="q4" selected>Q4 — 4-bit (fastest · smallest)</option>
              <option value="q8">Q8 — 8-bit (balanced quality)</option>
              <option value="f16">F16 — half precision</option>
              <option value="f32">F32 — full precision (debug)</option>
            </select>
          </div>
          <div class="opt-field">
            <div class="opt-label">Shard size</div>
            <select class="opt-select" id="shardSize" onchange="onExpertChange()">
              <option value="134217728">128 MB</option>
              <option value="268435456">256 MB</option>
              <option value="536870912" selected>512 MB (recommended)</option>
              <option value="1073741824">1 GB</option>
            </select>
          </div>
        </div>
        <div class="opt-metrics" id="optMetrics">
          <span style="color:var(--muted);font-size:.63rem;margin-right:.2rem">Config:</span>
          <span class="opt-metric" id="metricQuant"><span class="material-icons-round">compress</span>—</span>
          <span class="opt-metric" id="metricShard"><span class="material-icons-round">storage</span>—</span>
          <span class="opt-metric" id="metricSpeed"><span class="material-icons-round">speed</span>—</span>
          <span class="opt-metric" id="metricAccuracy"><span class="material-icons-round">analytics</span>—</span>
        </div>
      </div>
    </div>
  </div>

  <!-- ══ STEP 3: Convert ══ -->
  <div class="conv-card">
    <div class="conv-card-title">
      <span class="material-icons-round">bolt</span>
      3 — Convert &amp; export
    </div>

    <div class="progress-section" id="progressSection">
      <div class="progress-track" style="margin-bottom:.55rem">
        <div class="progress-fill" id="convProgressFill" style="width:0%"></div>
      </div>
      <div class="progress-row">
        <div class="progress-status" id="convStatus">Starting…</div>
        <div class="progress-label" id="convPct">0%</div>
      </div>
      <div class="progress-log" id="progressLog"></div>
    </div>

    <div class="result-section" id="resultSection">
      <div class="result-stat">
        <span class="result-stat-label">Model</span>
        <span class="result-stat-val" id="resModel">—</span>
      </div>
      <div class="result-stat">
        <span class="result-stat-label">Architecture</span>
        <span class="result-stat-val" id="resArch">—</span>
      </div>
      <div class="result-stat">
        <span class="result-stat-label">Tensors converted</span>
        <span class="result-stat-val" id="resTensors">—</span>
      </div>
      <div class="result-stat">
        <span class="result-stat-label">Shards created</span>
        <span class="result-stat-val" id="resShards">—</span>
      </div>
      <div class="result-stat">
        <span class="result-stat-label">Quantization</span>
        <span class="result-stat-val purple" id="resQuant">—</span>
      </div>
      <div class="result-stat">
        <span class="result-stat-label">Total output size</span>
        <span class="result-stat-val green" id="resSize">—</span>
      </div>
      <div class="result-stat" id="resSpeedRow" style="display:none">
        <span class="result-stat-label">Expected inference speed</span>
        <span class="result-stat-val green" id="resSpeed">—</span>
      </div>
      <div class="action-row">
        <button class="action-btn primary" onclick="downloadModel()">
          <span class="material-icons-round">download</span>
          Download .acc bundle
        </button>
        <button class="action-btn" onclick="saveToOPFSModel()" id="opfsBtn">
          <span class="material-icons-round">save</span>
          Save to browser cache
        </button>
      </div>
      <div style="font-size:.6rem;color:var(--muted);line-height:1.7">
        <strong>Download</strong> saves to a folder you can upload to your CDN.<br>
        <strong>Browser cache</strong> uses OPFS — instant load on next session for testing.
      </div>
    </div>

    <button class="conv-btn" id="convBtn" onclick="startConversion()">
      <span class="material-icons-round">auto_fix_high</span>
      Download &amp; Convert
    </button>
  </div>

  <div class="conv-info">
    <span class="material-icons-round">lock</span>
    <span>100% browser-native. No data is uploaded to any server. All downloading, conversion, quantization and caching happens entirely on your device.</span>
  </div>

</div>

<!-- ── FOOTER ── -->
<footer class="site-footer">
  <div class="footer-inner">
    <img class="footer-logo footer-logo-light"
      src="https://i.ibb.co/mV4rQV7B/Chat-GPT-Image-18-Feb-2026-08-42-07.png" alt="LocalLLM by Actalithic">
    <img class="footer-logo footer-logo-dark"
      src="https://i.ibb.co/tpSTrg7Z/whitelogo.png" alt="LocalLLM by Actalithic">
    <span class="footer-copy">© 2026 Actalithic · LocalLLM</span>
    <div class="footer-links">
      <a class="footer-link" href="index.html">LocalLLM</a>
      <span class="footer-sep">·</span>
      <a class="footer-link" href="blog.html">Blog</a>
      <span class="footer-sep">·</span>
      <a class="footer-link" href="https://bsky.app/profile/actalithic.bsky.social" target="_blank" rel="noopener">
        <svg viewBox="0 0 600 530" xmlns="http://www.w3.org/2000/svg"><path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z" fill="currentColor"/></svg>
        Bluesky
      </a>
      <span class="footer-sep">·</span>
      <a class="footer-link" href="https://github.com/actalithic" target="_blank" rel="noopener">GitHub</a>
    </div>
  </div>
</footer>

<script type="module">
import { convertSafetensors, downloadBundle, saveToOPFS } from './js/acc-converter.js';
import { toggleTheme } from './js/theme.js';
window.toggleTheme = toggleTheme;

// ── Theme ────────────────────────────────────────────────────────────────────
function applyLogos() {
  const d = document.documentElement.getAttribute('data-theme') === 'dark';
  document.querySelectorAll('.logo-light,.footer-logo-light').forEach(e => e.style.display = d ? 'none' : 'block');
  document.querySelectorAll('.logo-dark,.footer-logo-dark').forEach(e =>  e.style.display = d ? 'block' : 'none');
  const ic = document.getElementById('themeIcon');
  if (ic) ic.textContent = d ? 'light_mode' : 'dark_mode';
}
applyLogos();
new MutationObserver(applyLogos).observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });

// ── State ────────────────────────────────────────────────────────────────────
let _activeModel   = null;   // selected MODELS entry
let _bundle        = null;
let _kernelsSrc    = null;
let _activePreset  = 'extreme';

fetch('./webgpu/kernels.wgsl').then(r => r.text()).then(t => { _kernelsSrc = t; }).catch(() => {});

// ── Model catalogue — these are the exact models LocalLLM ships ──────────────
const MODELS = [
  {
    id:          'llama-3.2-3b.acc',
    name:        'Llama 3.2 3B',
    creator:     'Meta',
    tier:        'Light',
    size:        '~2 GB',
    arch:        'llama',
    outputName:  'llama-3.2-3b',
    desc:        'Fastest model — great for all devices including mobile.',
    tags:        [['Light', 'green'], ['LLaMA 3', 'purple'], ['2 GB', 'blue']],
    // Public unsharded mirror — no login needed
    hfBase:      'https://huggingface.co/unsloth/Llama-3.2-3B-Instruct/resolve/main',
    hfWeights:   'model.safetensors',
    hfTokenizer: 'tokenizer.json',
  },
  {
    id:          'mistral-7b-instruct.acc',
    name:        'Mistral 7B',
    creator:     'Mistral AI',
    tier:        'Middle',
    size:        '~4 GB',
    arch:        'mistral',
    outputName:  'mistral-7b-instruct',
    desc:        'Well-rounded general-purpose model. Best balance of speed and quality.',
    tags:        [['Middle', 'amber'], ['Mistral', 'purple'], ['4 GB', 'blue']],
    // unsloth mirror is public (no login required); has model.safetensors.index.json
    hfBase:      'https://huggingface.co/unsloth/mistral-7b-instruct-v0.3/resolve/main',
    hfWeights:   'model.safetensors',
    hfTokenizer: 'tokenizer.json',
  },
  {
    id:          'deepseek-r1-8b.acc',
    name:        'DeepSeek R1 8B',
    creator:     'DeepSeek',
    tier:        'Advanced',
    size:        '~5 GB',
    arch:        'llama',
    outputName:  'deepseek-r1-8b',
    desc:        'Reasoning model with step-by-step thinking. Needs a powerful device.',
    tags:        [['Advanced', 'purple'], ['Reasoning', 'blue'], ['5 GB', 'amber']],
    hfBase:      'https://huggingface.co/deepseek-ai/DeepSeek-R1-Distill-Llama-8B/resolve/main',
    // No model.safetensors.index.json in this repo — shards are hardcoded here
    hfShards:    ['model-00001-of-000002.safetensors', 'model-00002-of-000002.safetensors'],
    hfWeights:   'model.safetensors',
    hfTokenizer: 'tokenizer.json',
  },
];

// ── Build model picker ────────────────────────────────────────────────────────
function buildModelPicker() {
  document.getElementById('modelPickerGrid').innerHTML = MODELS.map(m => `
    <div class="hf-model-card" data-mid="${m.id}" onclick="pickModel('${m.id}')">
      <div class="hf-card-name">${m.name}</div>
      <div class="hf-card-meta">
        <span>${m.creator}</span><span>·</span><span>${m.tier}</span><span>·</span><span>${m.size}</span>
      </div>
      <div class="hf-card-meta" style="margin-top:.2rem">
        ${m.tags.map(([t,c])=>`<span class="hf-card-tag ${c==='green'?'q4':c==='purple'?'acc':''}">${t}</span>`).join('')}
      </div>
      <div style="font-size:.63rem;color:var(--muted);margin-top:.35rem;line-height:1.5">${m.desc}</div>
    </div>
  `).join('');
}
buildModelPicker();

window.pickModel = function(id) {
  _activeModel = MODELS.find(m => m.id === id) || null;
  document.querySelectorAll('#modelPickerGrid .hf-model-card')
    .forEach(c => c.classList.toggle('selected', c.dataset.mid === id));
  // Update convert button label
  const btn = document.getElementById('convBtn');
  if (_activeModel) {
    btn.innerHTML = `<span class="material-icons-round">auto_fix_high</span> Download &amp; Convert ${_activeModel.name}`;
    btn.disabled = false;
  }
};

// ── Presets ──────────────────────────────────────────────────────────────────
const PRESETS = {
  extreme: {
    label: 'Extreme Speed', quant: 'q4', shardBytes: 536870912,
    speedEst: '15–80 tok/s depending on device',
    accuracyNote: 'ACC-optimised Q4 · ~98% quality · recommended',
    tags: [['Fastest', 'green'], ['Q4 ACC', 'purple'], ['Recommended', 'blue']],
    desc: 'Actalithic-optimised Q4 with per-block calibration — maximum inference speed. Recommended for all ACC models.',
  },
  balanced: {
    label: 'Balanced', quant: 'q8', shardBytes: 268435456,
    speedEst: '8–40 tok/s depending on device',
    accuracyNote: 'Q8 symmetric blocks · ~99.5% quality',
    tags: [['Balanced', 'amber'], ['Q8', 'purple'], ['High fidelity', 'blue']],
    desc: 'Q8 quantization — higher fidelity at moderate speed. Good for precise tasks.',
  },
  quality: {
    label: 'Max Quality', quant: 'f16', shardBytes: 268435456,
    speedEst: '5–20 tok/s depending on device',
    accuracyNote: 'F16 · near-lossless',
    tags: [['Near-lossless', 'green'], ['F16', 'purple'], ['2× size', 'amber']],
    desc: 'F16 half-precision — near-lossless accuracy when correctness matters most.',
  },
};

function buildPresets() {
  document.getElementById('presetGrid').innerHTML = Object.entries(PRESETS).map(([k, p]) => `
    <div class="preset-card ${k === _activePreset ? 'active' : ''}" data-preset="${k}" onclick="selectPreset('${k}')">
      <div class="preset-name">${p.label}</div>
      <div class="preset-desc">${p.desc}</div>
      <div class="preset-tags">${p.tags.map(([t,c])=>`<span class="preset-tag ${c}">${t}</span>`).join('')}</div>
    </div>
  `).join('');
}
buildPresets();

window.selectPreset = function(k) {
  _activePreset = k;
  const p = PRESETS[k];
  document.querySelectorAll('.preset-card').forEach(c => c.classList.toggle('active', c.dataset.preset === k));
  document.getElementById('quantMode').value  = p.quant;
  document.getElementById('shardSize').value  = String(p.shardBytes);
  document.getElementById('speedEstimateText').innerHTML =
    `<strong>${p.label}:</strong> ${p.speedEst} &nbsp;·&nbsp; ${p.accuracyNote}`;
  document.getElementById('speedEstimate').classList.add('visible');
  updateMetrics();
};
selectPreset('extreme');

function updateMetrics() {
  const q = document.getElementById('quantMode').value;
  const s = parseInt(document.getElementById('shardSize').value);
  const speedMap = { q4: '★★★★★ Extreme', q8: '★★★★☆ Fast', f16: '★★★☆☆ Moderate', f32: '★★☆☆☆ Slow' };
  const accMap   = { q4: '~98% accuracy',  q8: '~99.5% accuracy', f16: '~100% accuracy', f32: '100% accuracy' };
  document.getElementById('metricQuant').innerHTML    = `<span class="material-icons-round">compress</span>${q.toUpperCase()}`;
  document.getElementById('metricShard').innerHTML    = `<span class="material-icons-round">storage</span>${Math.round(s/1024/1024)} MB shards`;
  document.getElementById('metricSpeed').innerHTML    = `<span class="material-icons-round">speed</span>${speedMap[q]}`;
  document.getElementById('metricAccuracy').innerHTML = `<span class="material-icons-round">analytics</span>${accMap[q]}`;
  document.getElementById('metricSpeed').className    = 'opt-metric' + (q==='q4'?' hi':q==='q8'?' ok':'');
}

window.onExpertChange = function() {
  updateMetrics();
  _activePreset = null;
  document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
  document.getElementById('speedEstimate').classList.remove('visible');
};
window.toggleExpert = function() {
  document.getElementById('expertToggle').classList.toggle('open');
  document.getElementById('expertPanel').classList.toggle('open');
};

// ── Shard detection + streaming download + merge ─────────────────────────────
//
// Memory strategy: one shard in RAM at a time.
//
// OLD (bad):  download shard 1 → keep → download shard 2 → keep → merge all
//             Peak = sum(all shards) + merged output  ← tab-killing for 3×1.3 GB
//
// NEW (good): pre-allocate one output buffer sized to hold all tensor data,
//             then for each shard: stream → parse header → write tensors directly
//             into the output buffer → null the shard → move on.
//             Peak ≈ 1 shard + output buffer  (roughly half the old peak).
//
// Append ?download=true so HuggingFace serves the actual binary for
// Xet/LFS-backed files instead of returning a pointer file.
function hfUrl(base, fname) {
  return `${base}/${fname}?download=true`;
}

// ── Step 1: fetch just enough bytes to read a safetensors header ─────────────
// Safetensors layout: [8-byte LE uint64 header_len][header JSON bytes][data...]
// We fetch the first 64 KB (more than enough for any header), parse it,
// and return the tensor metadata + where in the stream tensor data begins.
async function fetchSafetensorsHeader(url) {
  // Range request: first 64 KB covers all known safetensors headers
  const PROBE = 65536;
  const resp = await fetch(url, { headers: { Range: `bytes=0-${PROBE - 1}` } });
  if (!resp.ok && resp.status !== 206) throw new Error(`HTTP ${resp.status}: ${url}`);
  const probe = new Uint8Array(await resp.arrayBuffer());
  const dv = new DataView(probe.buffer);
  const headerLen = dv.getUint32(0, true); // lo 32 bits (hi bits always 0 in practice)
  if (headerLen > PROBE - 8) throw new Error(`Safetensors header too large (${headerLen} bytes)`);
  const headerStr = new TextDecoder().decode(probe.slice(8, 8 + headerLen));
  const header = JSON.parse(headerStr);
  const dataStart = 8 + headerLen; // byte offset where tensor data begins in the file
  return { header, dataStart };
}

// ── Step 2: stream a shard and write tensors straight into `outView` ─────────
// `tensorMap` is built up across shards: { name → { dtype, shape, data_offsets } }
// `writePtr` is a { value } box so callers can advance it across shards.
async function streamShardIntoBuffer(url, outView, writePtr, tensorMap, onProgress) {
  // First get the header via a cheap range request
  const { header, dataStart } = await fetchSafetensorsHeader(url);

  // Now stream the full file; we only copy bytes that belong to tensors.
  const resp = await fetch(url, { headers: { Range: `bytes=${dataStart}-` } });
  if (!resp.ok && resp.status !== 206) throw new Error(`HTTP ${resp.status} streaming ${url}`);

  const contentLength = parseInt(resp.headers.get('content-length') || '0');
  const reader = resp.body.getReader();

  // Build a sorted list of tensor regions in file-offset order so we can
  // copy them as they arrive in the stream without random-access seeks.
  const regions = Object.entries(header)
    .filter(([n]) => n !== '__metadata__')
    .map(([name, meta]) => ({
      name,
      dtype:      meta.dtype,
      shape:      meta.shape,
      fileStart:  meta.data_offsets[0], // relative to dataStart
      fileEnd:    meta.data_offsets[1],
      byteLen:    meta.data_offsets[1] - meta.data_offsets[0],
    }))
    .sort((a, b) => a.fileStart - b.fileStart);

  // Register tensors in the output map with their final positions
  for (const r of regions) {
    tensorMap[r.name] = {
      dtype:        r.dtype,
      shape:        r.shape,
      data_offsets: [writePtr.value, writePtr.value + r.byteLen],
    };
    writePtr.value += r.byteLen;
  }
  // Rewind writePtr — we'll advance it again as we actually write bytes
  // (recalculate from the registered offsets instead)
  // Actually: capture the start offset per region from the map we just built.
  // Simpler: keep a per-region write cursor from the map entries.

  // We walk the stream and copy bytes region-by-region.
  let regionIdx = 0;
  let streamPos = 0;          // bytes consumed from stream (relative to dataStart)
  let regionWritten = 0;      // bytes written into current region
  let totalLoaded = 0;

  // Carry buffer for partial chunk leftovers
  let carry = null;

  const flushChunk = (chunk) => {
    let chunkPos = 0;
    while (chunkPos < chunk.length && regionIdx < regions.length) {
      const r = regions[regionIdx];
      const outStart = tensorMap[r.name].data_offsets[0]; // absolute in outView
      const remaining = r.byteLen - regionWritten;

      // Skip bytes before this region (padding / alignment bytes between tensors)
      const gapStart = r.fileStart;
      if (streamPos < gapStart) {
        const skip = Math.min(gapStart - streamPos, chunk.length - chunkPos);
        streamPos += skip;
        chunkPos  += skip;
        continue;
      }

      // Copy as many bytes as available into this region
      const toCopy = Math.min(remaining, chunk.length - chunkPos);
      outView.set(chunk.subarray(chunkPos, chunkPos + toCopy), outStart + regionWritten);
      regionWritten += toCopy;
      chunkPos      += toCopy;
      streamPos     += toCopy;

      if (regionWritten >= r.byteLen) {
        regionIdx++;
        regionWritten = 0;
      }
    }
  };

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    totalLoaded += value.length;
    onProgress(totalLoaded, contentLength);

    // Prepend any leftover carry bytes from previous chunk
    const chunk = carry ? concatU8(carry, value) : value;
    carry = null;
    flushChunk(chunk);
  }
}

function concatU8(a, b) {
  const out = new Uint8Array(a.length + b.length);
  out.set(a, 0); out.set(b, a.length);
  return out;
}

// ── Step 3: quick-scan all shard headers to know total tensor data size ───────
// This costs one range-request per shard (~tiny) so we can pre-allocate exactly.
async function scanShardSizes(base, shardFiles) {
  let totalData = 0;
  const metas = [];
  for (const fname of shardFiles) {
    const { header, dataStart } = await fetchSafetensorsHeader(hfUrl(base, fname));
    let shardDataSize = 0;
    const tensors = [];
    for (const [name, meta] of Object.entries(header)) {
      if (name === '__metadata__') continue;
      const len = meta.data_offsets[1] - meta.data_offsets[0];
      shardDataSize = Math.max(shardDataSize, meta.data_offsets[1]);
      tensors.push({ name, dtype: meta.dtype, shape: meta.shape,
                     fileStart: meta.data_offsets[0], fileEnd: meta.data_offsets[1] });
    }
    totalData += shardDataSize;
    metas.push({ fname, header, dataStart, tensors, shardDataSize });
  }
  return { totalData, metas };
}

// ── Main entry: detect shards → pre-alloc → stream each shard in place ───────
async function loadModelWeights(m, onStatus) {
  const base = m.hfBase;

  // ── 1. Resolve shard list ─────────────────────────────────────────────────
  let shardFiles = m.hfShards || null;
  if (!shardFiles) {
    try {
      const idxResp = await fetch(hfUrl(base, 'model.safetensors.index.json'));
      if (idxResp.ok) {
        const idx = await idxResp.json();
        shardFiles = [...new Set(Object.values(idx.weight_map))].sort();
      }
    } catch {}
  }

  // ── 2. Single-file fast path ──────────────────────────────────────────────
  if (!shardFiles || shardFiles.length <= 1) {
    const fname = shardFiles?.[0] || m.hfWeights || 'model.safetensors';
    onStatus(`Downloading ${fname}…`);
    return fetchSingleWithProgress(hfUrl(base, fname), (loaded, total) => {
      const pct = total > 0 ? Math.round(loaded / total * 100) : 0;
      setDlStatus('loading',
        `Downloading ${fname} — ${fmtBytes(loaded)}${total ? ' / ' + fmtBytes(total) + ' (' + pct + '%)' : ''}`,
        true, pct);
    });
  }

  // ── 3. Multi-shard: scan headers first (cheap range requests) ────────────
  onStatus(`Scanning ${shardFiles.length} shard headers…`);
  setDlStatus('loading', `Reading shard manifests (${shardFiles.length} files)…`, false, 0);
  const { totalData, metas } = await scanShardSizes(base, shardFiles);

  // ── 4. Build the merged safetensors output buffer in one allocation ───────
  // Merged safetensors layout:
  //   [8 bytes header_len][merged header JSON + padding][all tensor data]
  //
  // We need to build the merged header first so we know its size.
  // Assign output positions to each tensor (sorted for determinism).
  let dataOffset = 0;
  const mergedHeader = {};
  for (const { tensors } of metas) {
    for (const t of tensors) {
      mergedHeader[t.name] = {
        dtype:        t.dtype,
        shape:        t.shape,
        data_offsets: [dataOffset, dataOffset + (t.fileEnd - t.fileStart)],
      };
      dataOffset += (t.fileEnd - t.fileStart);
    }
  }

  const headerJson  = JSON.stringify(mergedHeader);
  const headerBytes = new TextEncoder().encode(headerJson);
  const pad         = (8 - (headerBytes.length % 8)) % 8;
  const paddedLen   = headerBytes.length + pad;
  const totalBytes  = 8 + paddedLen + dataOffset;

  onStatus(`Pre-allocating ${fmtBytes(totalBytes)} output buffer…`);
  const out = new Uint8Array(totalBytes);
  const dv  = new DataView(out.buffer);
  dv.setUint32(0, paddedLen, true);
  dv.setUint32(4, 0, true);
  out.set(headerBytes, 8);
  for (let i = 0; i < pad; i++) out[8 + headerBytes.length + i] = 0x20;

  // The tensor data section starts at byte (8 + paddedLen) in `out`.
  // mergedHeader[name].data_offsets are relative to the tensor data section.
  const dataSection = new Uint8Array(out.buffer, 8 + paddedLen, dataOffset);

  // ── 5. Stream each shard → write directly into dataSection → null shard ──
  // Build a lookup: tensor name → write offset within dataSection
  const tensorWriteOffset = {};
  for (const [name, meta] of Object.entries(mergedHeader)) {
    tensorWriteOffset[name] = meta.data_offsets[0];
  }

  let totalDownloaded = 0;
  const totalDownloadBytes = metas.reduce((s, m) => s + m.shardDataSize, 0);

  for (let si = 0; si < metas.length; si++) {
    const { fname, header, dataStart } = metas[si];
    onStatus(`Streaming shard ${si + 1}/${metas.length}: ${fname}`);

    // Stream tensor data (skip the header we already have)
    const url  = hfUrl(base, fname);
    const resp = await fetch(url, { headers: { Range: `bytes=${dataStart}-` } });
    if (!resp.ok && resp.status !== 206) throw new Error(`HTTP ${resp.status}: ${fname}`);
    const contentLen = parseInt(resp.headers.get('content-length') || '0');
    const reader = resp.body.getReader();

    // Sort tensors in file order so we can copy linearly as bytes arrive
    const regions = Object.entries(header)
      .filter(([n]) => n !== '__metadata__')
      .map(([name, meta]) => ({
        name,
        fileStart: meta.data_offsets[0],
        fileEnd:   meta.data_offsets[1],
        byteLen:   meta.data_offsets[1] - meta.data_offsets[0],
      }))
      .sort((a, b) => a.fileStart - b.fileStart);

    let streamPos     = 0; // bytes consumed from this shard's data stream
    let regionIdx     = 0;
    let regionWritten = 0;
    let shardLoaded   = 0;
    let carry         = null; // leftover bytes between chunks

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      shardLoaded   += value.length;
      totalDownloaded += value.length;

      const pct = totalDownloadBytes > 0
        ? Math.round(totalDownloaded / totalDownloadBytes * 100) : 0;
      setDlStatus('loading',
        `Shard ${si + 1}/${metas.length}: ${fname} — ${fmtBytes(shardLoaded)}${contentLen ? ' / ' + fmtBytes(contentLen) : ''} (total ${fmtBytes(totalDownloaded)})`,
        true, pct);

      // Merge carry + new chunk
      let chunk = carry ? concatU8(carry, value) : value;
      carry = null;

      // Walk through chunk copying bytes into the right tensor slots
      let cp = 0; // chunk pointer
      while (cp < chunk.length && regionIdx < regions.length) {
        const r = regions[regionIdx];

        // Skip padding / alignment bytes before this region
        if (streamPos < r.fileStart) {
          const skip = Math.min(r.fileStart - streamPos, chunk.length - cp);
          streamPos += skip; cp += skip;
          continue;
        }

        const dstOffset = tensorWriteOffset[r.name] + regionWritten;
        const toCopy    = Math.min(r.byteLen - regionWritten, chunk.length - cp);
        dataSection.set(chunk.subarray(cp, cp + toCopy), dstOffset);
        regionWritten += toCopy;
        streamPos     += toCopy;
        cp            += toCopy;

        if (regionWritten >= r.byteLen) { regionIdx++; regionWritten = 0; }
      }

      // Save unconsumed tail (shouldn't happen at end-of-regions, but safe)
      if (cp < chunk.length) carry = chunk.slice(cp);
    }

    // ── Shard done — release all references so GC can reclaim it ─────────
    carry = null;
    // (reader is exhausted; no buffer held)
    onStatus(`Shard ${si + 1}/${metas.length} done — RAM freed`);
  }

  onStatus('All shards streamed — returning merged buffer');
  setDlStatus('ok', `All ${metas.length} shards downloaded & merged (${fmtBytes(totalBytes)})`, false, 100);
  return out.buffer;
}

// ── Single-file streaming download (no merge needed) ─────────────────────────
async function fetchSingleWithProgress(url, onProgress) {
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${url}`);
  const total = parseInt(resp.headers.get('content-length') || '0');
  let loaded = 0;
  const reader = resp.body.getReader();
  const chunks = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value); loaded += value.length;
    onProgress(loaded, total);
  }
  const out = new Uint8Array(loaded);
  let off = 0;
  for (const c of chunks) { out.set(c, off); off += c.length; }
  return out.buffer;
}

function setDlStatus(type, text, showBar = false, pct = 0) {
  const el = document.getElementById('dlStatus');
  el.style.display = 'flex';
  el.className = 'hf-status visible' + (type === 'ok' ? ' ok' : type === 'err' ? ' err' : '');
  document.getElementById('dlStatusIcon').textContent =
    type === 'ok' ? 'check_circle' : type === 'err' ? 'error' : 'downloading';
  document.getElementById('dlStatusText').textContent = text;
  const bar = document.getElementById('dlProgress');
  bar.style.display = showBar ? 'block' : 'none';
  if (showBar) document.getElementById('dlFill').style.width = pct + '%';
}

// ── Main conversion flow ──────────────────────────────────────────────────────
window.startConversion = async function() {
  if (!_activeModel) {
    alert('Please select a model first (Step 1).');
    return;
  }

  const btn    = document.getElementById('convBtn');
  const quant  = document.getElementById('quantMode').value;
  const shard  = parseInt(document.getElementById('shardSize').value);
  const preset = _activePreset ? PRESETS[_activePreset] : null;

  btn.disabled = true;
  btn.innerHTML = '<span class="material-icons-round">hourglass_empty</span> Working…';
  document.getElementById('progressSection').classList.add('visible');
  document.getElementById('resultSection').classList.remove('visible');
  document.getElementById('progressLog').innerHTML = '';

  function onConvProgress(pct, msg) {
    document.getElementById('convProgressFill').style.width = pct + '%';
    document.getElementById('convStatus').textContent = msg;
    document.getElementById('convPct').textContent = pct + '%';
    const log  = document.getElementById('progressLog');
    const line = document.createElement('div'); line.className = 'log-line';
    line.innerHTML = `<span class="log-pct">${pct}%</span><span class="log-msg">${msg}</span>`;
    log.appendChild(line); log.scrollTop = log.scrollHeight;
  }

  try {
    const m = _activeModel;

    // ── Step A: Download weights (auto-detects single vs multi-shard) ───────
    onConvProgress(1, `Detecting ${m.name} model files…`);
    let weightsBuffer;
    try {
      weightsBuffer = await loadModelWeights(m, (msg) => onConvProgress(2, msg));
    } catch(e) {
      throw new Error(`Download failed: ${e.message}`);
    }
    const dlSize = fmtBytes(weightsBuffer.byteLength);
    setDlStatus('ok', `${m.name} downloaded (${dlSize})`, false, 100);
    onConvProgress(40, `Downloaded ${dlSize} — fetching tokenizer…`);

    // ── Step B: Tokenizer ───────────────────────────────────────────────────
    let tokenizerJson = null;
    try {
      const tr = await fetch(hfUrl(m.hfBase, m.hfTokenizer));
      if (tr.ok) tokenizerJson = await tr.text();
    } catch {}

    onConvProgress(42, 'Converting to .acc format…');

    // ── Step C: Convert ─────────────────────────────────────────────────────
    _bundle = await convertSafetensors(weightsBuffer, {
      quantMode:       quant,
      shardSizeBytes:  shard,
      onProgress:      (pct, msg) => onConvProgress(42 + Math.round(pct * 0.56), msg),
      configOverrides: { arch: m.arch },
      tokenizerJson,
      kernelsSrc:      _kernelsSrc,
      optimized:       true,
      blockSize:       quant === 'q4' ? 128 : 64,
      calibrateBlocks: true,
    });
    weightsBuffer = null; // free RAM

    // ── Show results ────────────────────────────────────────────────────────
    const manifest = _bundle.manifest;
    const config   = _bundle.config;
    document.getElementById('resModel').textContent    = m.name;
    document.getElementById('resArch').innerHTML       = `${config.arch || m.arch} <span class="arch-badge">${manifest.quant?.toUpperCase()}</span>`;
    document.getElementById('resTensors').textContent  = manifest.tensor_count;
    document.getElementById('resShards').textContent   = manifest.num_shards;
    document.getElementById('resQuant').textContent    = manifest.quant?.toUpperCase() + (preset?.accuracyNote ? ' — ' + preset.accuracyNote : '');
    document.getElementById('resSize').textContent     = fmtBytes(_bundle.shards.reduce((s, b) => s + b.byteLength, 0));
    if (preset?.speedEst) {
      document.getElementById('resSpeed').textContent = preset.speedEst;
      document.getElementById('resSpeedRow').style.display = 'flex';
    } else {
      document.getElementById('resSpeedRow').style.display = 'none';
    }
    document.getElementById('resultSection').classList.add('visible');
    onConvProgress(100, 'Done! Download or save to browser cache below.');
    btn.innerHTML = '<span class="material-icons-round">check_circle</span> Conversion complete!';

  } catch (err) {
    onConvProgress(0, 'Error: ' + err.message);
    setDlStatus('err', err.message, false, 0);
    console.error(err);
    btn.disabled = false;
    btn.innerHTML = `<span class="material-icons-round">auto_fix_high</span> Retry — Download &amp; Convert ${_activeModel?.name || ''}`;
  }
};

window.downloadModel = async function() {
  if (!_bundle) return;
  try { await downloadBundle(_bundle, _activeModel?.outputName || 'model'); }
  catch(e) { if (e.name !== 'AbortError') alert('Download failed: ' + e.message); }
};

window.saveToOPFSModel = async function() {
  if (!_bundle) return;
  const btn = document.getElementById('opfsBtn');
  btn.disabled = true;
  btn.innerHTML = '<span class="material-icons-round">hourglass_empty</span> Saving…';
  try {
    await saveToOPFS(_bundle, _activeModel?.outputName || 'model');
    btn.innerHTML = '<span class="material-icons-round">check_circle</span> Saved to cache!';
    btn.style.color = 'var(--green)';
  } catch(e) {
    alert('OPFS save failed: ' + e.message);
    btn.disabled = false;
    btn.innerHTML = '<span class="material-icons-round">save</span> Save to browser cache';
  }
};

function fmtBytes(b) {
  if (b >= 1e9) return (b / 1e9).toFixed(2) + ' GB';
  if (b >= 1e6) return (b / 1e6).toFixed(1) + ' MB';
  if (b >= 1e3) return (b / 1e3).toFixed(0) + ' KB';
  return b + ' B';
}
</script>
</body>
</html>
